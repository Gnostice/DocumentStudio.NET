<?xml version="1.0"?>
<doc>
    <assembly>
        <name>BitMiracle.LibJpeg.NET</name>
    </assembly>
    <members>
        <member name="M:BitMiracle.LibJpeg.BitmapDestination.BeginWrite">
            <summary>
            Startup: normally writes the file header.
            In this module we may as well postpone everything until finish_output.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.BitmapDestination.ProcessPixelsRow(System.Byte[])">
            <summary>
            Write some pixel data.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.BitmapDestination.EndWrite">
            <summary>
            Finish up at the end of the file.
            Here is where we really output the BMP file.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.BitmapDestination.putGrayRow(System.Byte[])">
            <summary>
            This version is for grayscale OR quantized color output
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.BitmapDestination.putRgbRow(System.Byte[])">
            <summary>
            This version is for writing 24-bit pixels
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.BitmapDestination.putCmykRow(System.Byte[])">
            <summary>
            This version is for writing 24-bit pixels
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.BitmapDestination.writeHeader">
            <summary>
            Write a Windows-style BMP file header, including colormap if needed
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.BitmapDestination.writeColormap(System.Int32,System.Int32)">
            <summary>
            Write the colormap.
            Windows uses BGR0 map entries; OS/2 uses BGR entries.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.DensityUnit">
            <summary>
            The unit of density.
            </summary>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Density_unit"/>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Density_unit"/>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.DensityUnit.Unknown">
            <summary>
            Unknown density
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.DensityUnit.DotsInch">
            <summary>
            Dots/inch
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.DensityUnit.DotsCm">
            <summary>
            Dots/cm
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.bitread_perm_state">
            <summary>
            Bitreading state saved across MCUs
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer">
            <summary>
            Encapsulates buffer of image samples for one color component
            When provided with funny indices (see jpeg_d_main_controller for 
            explanation of what it is) uses them for non-linear row access.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.d_derived_tbl">
            <summary>
            Derived data constructed for each Huffman table
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_decoder">
            <summary>
            Expanded entropy decoder object for Huffman decoding.
            
            The savable_state subrecord contains fields that change within an MCU,
            but must not be updated permanently until we complete the MCU.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_decoder.start_pass">
            <summary>
            Initialize for a Huffman-compressed scan.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_decoder.decode_mcu_full(BitMiracle.LibJpeg.Classic.JBLOCK[])">
            <summary>
            Decode one MCU's worth of Huffman-compressed coefficients, full-size blocks.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_decoder.decode_mcu_sub(BitMiracle.LibJpeg.Classic.JBLOCK[])">
            <summary>
            Decode one MCU's worth of Huffman-compressed coefficients, partial blocks.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_decoder.decode_mcu_DC_first(BitMiracle.LibJpeg.Classic.JBLOCK[])">
            <summary>
            MCU decoding for DC initial scan (either spectral selection,
            or first pass of successive approximation).
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_decoder.decode_mcu_AC_first(BitMiracle.LibJpeg.Classic.JBLOCK[])">
            <summary>
            MCU decoding for AC initial scan (either spectral selection,
            or first pass of successive approximation).
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_decoder.decode_mcu_DC_refine(BitMiracle.LibJpeg.Classic.JBLOCK[])">
            <summary>
            MCU decoding for DC successive approximation refinement scan.
            Note: we assume such scans can be multi-component,
            although the spec is not very clear on the point.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_decoder.process_restart">
            <summary>
            Check for a restart marker and resynchronize decoder.
            Returns false if must suspend.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_decoder.jpeg_make_d_derived_tbl(System.Boolean,System.Int32,BitMiracle.LibJpeg.Classic.Internal.d_derived_tbl@)">
            <summary>
            Expand a Huffman table definition into the derived format
            This routine also performs some validation checks on the table.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder">
            <summary>
            Expanded entropy encoder object for Huffman encoding.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.start_pass(System.Boolean)">
            <summary>
            Initialize for a Huffman-compressed scan.
            If gather_statistics is true, we do not output anything during the scan,
            just count the Huffman symbols used and generate Huffman code tables.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.encode_mcu_huff(BitMiracle.LibJpeg.Classic.JBLOCK[][])">
            <summary>
            Encode and output one MCU's worth of Huffman-compressed coefficients.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.finish_pass_huff">
            <summary>
            Finish up at the end of a Huffman-compressed scan.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.encode_mcu_gather(BitMiracle.LibJpeg.Classic.JBLOCK[][])">
            <summary>
            Trial-encode one MCU's worth of Huffman-compressed coefficients.
            No data is actually output, so no suspension return is possible.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.finish_pass_gather">
            <summary>
            Finish up a statistics-gathering pass and create the new Huffman tables.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.encode_one_block(BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.savable_state,System.Int16[],System.Int32,BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.c_derived_tbl,BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.c_derived_tbl)">
            <summary>
            Encode a single block's worth of coefficients
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.htest_one_block(System.Int16[],System.Int32,System.Int64[],System.Int64[])">
            <summary>
            Huffman coding optimization.
            
            We first scan the supplied data and count the number of uses of each symbol
            that is to be Huffman-coded. (This process MUST agree with the code above.)
            Then we build a Huffman coding tree for the observed counts.
            Symbols which are not needed at all for the particular image are not
            assigned any code, which saves space in the DHT marker as well as in
            the compressed data.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.emit_bits_s(BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.savable_state,System.Int32,System.Int32)">
            <summary>
            Only the right 24 bits of put_buffer are used; the valid bits are
            left-justified in this part.  At most 16 bits can be passed to emit_bits
            in one call, and we never retain more than 7 bits in put_buffer
            between calls, so 24 bits are sufficient.
            </summary>
            Emit some bits; return true if successful, false if must suspend
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.emit_bits_e(System.Int32,System.Int32)">
            <summary>
            Outputting bits to the file
            
            Only the right 24 bits of put_buffer are used; the valid bits are
            left-justified in this part.  At most 16 bits can be passed to emit_bits
            in one call, and we never retain more than 7 bits in put_buffer
            between calls, so 24 bits are sufficient.
            </summary>
            Emit some bits, unless we are in gather mode
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.emit_restart_s(BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.savable_state,System.Int32)">
            <summary>
            Emit a restart marker and resynchronize predictions.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.IRIGHT_SHIFT(System.Int32,System.Int32)">
            <summary>
            IRIGHT_SHIFT is like RIGHT_SHIFT, but works on int rather than int.
            We assume that int right shift is unsigned if int right shift is,
            which should be safe.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.encode_mcu_DC_first(BitMiracle.LibJpeg.Classic.JBLOCK[][])">
            <summary>
            MCU encoding for DC initial scan (either spectral selection,
            or first pass of successive approximation).
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.encode_mcu_AC_first(BitMiracle.LibJpeg.Classic.JBLOCK[][])">
            <summary>
            MCU encoding for AC initial scan (either spectral selection,
            or first pass of successive approximation).
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.encode_mcu_DC_refine(BitMiracle.LibJpeg.Classic.JBLOCK[][])">
            <summary>
            MCU encoding for DC successive approximation refinement scan.
            Note: we assume such scans can be multi-component, although the spec
            is not very clear on the point.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.encode_mcu_AC_refine(BitMiracle.LibJpeg.Classic.JBLOCK[][])">
            <summary>
            MCU encoding for AC successive approximation refinement scan.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.jpeg_make_c_derived_tbl(System.Boolean,System.Int32,BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.c_derived_tbl@)">
            <summary>
            Expand a Huffman table definition into the derived format
            Compute the derived values for a Huffman table.
            This routine also performs some validation checks on the table.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.jpeg_gen_optimal_table(BitMiracle.LibJpeg.Classic.JHUFF_TBL,System.Int64[])">
            <summary>
            Generate the best Huffman code table for the given counts, fill htbl.
            
            The JPEG standard requires that no symbol be assigned a codeword of all
            one bits (so that padding bits added at the end of a compressed segment
            can't look like a valid code).  Because of the canonical ordering of
            codewords, this just means that there must be an unused slot in the
            longest codeword length category.  Section K.2 of the JPEG spec suggests
            reserving such a slot by pretending that symbol 256 is a valid symbol
            with count 1.  In theory that's not optimal; giving it count zero but
            including it in the symbol set anyway should give a better Huffman code.
            But the theoretically better code actually seems to come out worse in
            practice, because it produces more all-ones bytes (which incur stuffed
            zero bytes in the final file).  In any case the difference is tiny.
            
            The JPEG standard requires Huffman codes to be no more than 16 bits long.
            If some symbols have a very small but nonzero probability, the Huffman tree
            must be adjusted to meet the code length restriction.  We currently use
            the adjustment method suggested in JPEG section K.2.  This method is *not*
            optimal; it may not choose the best possible limited-length code.  But
            typically only very-low-frequency symbols will be given less-than-optimal
            lengths, so the code is almost optimal.  Experimental comparisons against
            an optimal limited-length-code algorithm indicate that the difference is
            microscopic --- usually less than a hundredth of a percent of total size.
            So the extra complexity of an optimal algorithm doesn't seem worthwhile.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.Internal.JpegUtils.jpeg_natural_order7">
            zz to natural order for 7x7 block
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.Internal.JpegUtils.jpeg_natural_order6">
            zz to natural order for 6x6 block
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.Internal.JpegUtils.jpeg_natural_order5">
            zz to natural order for 5x5 block
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.Internal.JpegUtils.jpeg_natural_order4">
            zz to natural order for 4x4 block
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.Internal.JpegUtils.jpeg_natural_order3">
            zz to natural order for 3x3 block
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.Internal.JpegUtils.jpeg_natural_order2">
            zz to natural order for 2x2 block
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.Internal.JpegUtils.jpeg_aritab">
            Arithmetic coding probability estimation tables
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.JpegUtils.jdiv_round_up(System.Int64,System.Int64)">
            <summary>
            Compute a/b rounded up to next integer, ie, ceil(a/b)
            Assumes a >= 0, b > 0
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.JpegUtils.jround_up(System.Int32,System.Int32)">
            <summary>
            Compute a rounded up to next multiple of b, ie, ceil(a/b)*b
            Assumes a >= 0, b > 0
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.JpegUtils.jcopy_sample_rows(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer,System.Int32,System.Byte[][],System.Int32,System.Int32,System.Int32)">
            <summary>
            Copy some rows of samples from one place to another.
            num_rows rows are copied from input_array[source_row++]
            to output_array[dest_row++]; these areas may overlap for duplication.
            The source and destination arrays must be at least as wide as num_cols.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_converter">
            <summary>
            Colorspace conversion
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_converter.color_convert">
            <summary>
            Convert some rows of samples to the JPEG colorspace.
            
            Note that we change from the application's interleaved-pixel format
            to our internal noninterleaved, one-plane-per-component format.
            The input buffer is therefore three times as wide as the output buffer.
            
            A starting row offset is provided only for the output buffer.  The caller
            can easily adjust the passed input_buf value to accommodate any row
            offset required on that side.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_converter.rgb_ycc_start">
            <summary>
            Initialize for RGB->YCC colorspace conversion.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_converter.rgb_ycc_convert(System.Byte[][],System.Int32,System.Byte[][][],System.Int32,System.Int32)">
            <summary>
            RGB -&gt; YCbCr conversion: most common case
            YCbCr is defined per CCIR 601-1, except that Cb and Cr are
            normalized to the range 0..MAXJSAMPLE rather than -0.5 .. 0.5.
            The conversion equations to be implemented are therefore
            Y  =  0.29900 * R + 0.58700 * G + 0.11400 * B
            Cb = -0.16874 * R - 0.33126 * G + 0.50000 * B  + CENTERJSAMPLE
            Cr =  0.50000 * R - 0.41869 * G - 0.08131 * B  + CENTERJSAMPLE
            (These numbers are derived from TIFF 6.0 section 21, dated 3-June-92.)
            To avoid floating-point arithmetic, we represent the fractional constants
            as integers scaled up by 2^16 (about 4 digits precision); we have to divide
            the products by 2^16, with appropriate rounding, to get the correct answer.
            For even more speed, we avoid doing any multiplications in the inner loop
            by precalculating the constants times R,G,B for all possible values.
            For 8-bit JSAMPLEs this is very reasonable (only 256 entries per table);
            for 12-bit samples it is still acceptable.  It's not very reasonable for
            16-bit samples, but if you want lossless storage you shouldn't be changing
            colorspace anyway.
            The CENTERJSAMPLE offsets and the rounding fudge-factor of 0.5 are included
            in the tables to save adding them separately in the inner loop.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_converter.rgb_gray_convert(System.Byte[][],System.Int32,System.Byte[][][],System.Int32,System.Int32)">
            <summary>
            Convert some rows of samples to the JPEG colorspace.
            This version handles RGB->grayscale conversion, which is the same
            as the RGB->Y portion of RGB->YCbCr.
            We assume rgb_ycc_start has been called (we only use the Y tables).
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_converter.cmyk_ycck_convert(System.Byte[][],System.Int32,System.Byte[][][],System.Int32,System.Int32)">
            <summary>
            Convert some rows of samples to the JPEG colorspace.
            This version handles Adobe-style CMYK->YCCK conversion,
            where we convert R=1-C, G=1-M, and B=1-Y to YCbCr using the same
            conversion as above, while passing K (black) unchanged.
            We assume rgb_ycc_start has been called.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_converter.grayscale_convert(System.Byte[][],System.Int32,System.Byte[][][],System.Int32,System.Int32)">
            <summary>
            Convert some rows of samples to the JPEG colorspace.
            This version handles grayscale output with no conversion.
            The source can be either plain grayscale or YCC (since Y == gray).
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_converter.null_convert(System.Byte[][],System.Int32,System.Byte[][][],System.Int32,System.Int32)">
            <summary>
            Convert some rows of samples to the JPEG colorspace.
            This version handles multi-component colorspaces without conversion.
            We assume input_components == num_components.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_deconverter">
            <summary>
            Colorspace conversion
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_deconverter.#ctor(BitMiracle.LibJpeg.Classic.jpeg_decompress_struct)">
            <summary>
            Module initialization routine for output colorspace conversion.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_deconverter.color_convert(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[],System.Int32[],System.Int32,System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Convert some rows of samples to the output colorspace.
            
            Note that we change from noninterleaved, one-plane-per-component format
            to interleaved-pixel format.  The output buffer is therefore three times
            as wide as the input buffer.
            A starting row offset is provided only for the input buffer.  The caller
            can easily adjust the passed output_buf value to accommodate any row
            offset required on that side.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_deconverter.build_ycc_rgb_table">
            <summary>
            Initialize tables for YCbCr->RGB colorspace conversion.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_deconverter.build_bg_ycc_rgb_table">
            <summary>
            Initialize tables for BG_YCC->RGB colorspace conversion.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_deconverter.ycck_cmyk_convert(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[],System.Int32,System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Adobe-style YCCK->CMYK conversion.
            We convert YCbCr to R=1-C, G=1-M, and B=1-Y using the same
            conversion as above, while passing K (black) unchanged.
            We assume build_ycc_rgb_table has been called.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_deconverter.gray_rgb_convert(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[],System.Int32,System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Convert grayscale to RGB: just duplicate the graylevel three times.
            This is provided to support applications that don't want to cope
            with grayscale as a separate case.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_deconverter.grayscale_convert(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[],System.Int32,System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Color conversion for grayscale: just copy the data.
            This also works for YCC -> grayscale conversion, in which
            we just copy the Y (luminance) component and ignore chrominance.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_deconverter.cmyk_rgb_convert(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[],System.Int32,System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Color conversion for CMYK -> RGB
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_deconverter.ycck_rgb_convert(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[],System.Int32,System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Color conversion for YCCK -> RGB
            it's just a gybrid of YCCK -> CMYK and CMYK -> RGB conversions
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_deconverter.null_convert(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[],System.Int32,System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Color conversion for no colorspace change: just copy the data,
            converting from separate-planes to interleaved representation.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_quantizer">
            <summary>
            Color quantization or color precision reduction
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_comp_master">
            <summary>
            Master control module
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_comp_master.prepare_for_pass">
            <summary>
            Per-pass setup.
            
            This is called at the beginning of each pass.  We determine which 
            modules will be active during this pass and give them appropriate 
            start_pass calls. 
            We also set is_last_pass to indicate whether any more passes will 
            be required.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_comp_master.pass_startup">
            <summary>
            Special start-of-pass hook.
            
            This is called by jpeg_write_scanlines if call_pass_startup is true.
            In single-pass processing, we need this hook because we don't want to
            write frame/scan headers during jpeg_start_compress; we want to let the
            application write COM markers etc. between jpeg_start_compress and the
            jpeg_write_scanlines loop.
            In multi-pass processing, this routine is not used.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_comp_master.finish_pass">
            <summary>
            Finish up at end of pass.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_comp_master.per_scan_setup">
            <summary>
            Do computations that are needed before processing a JPEG scan
            cinfo.comps_in_scan and cinfo.cur_comp_info[] are already set
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_c_coef_controller">
            <summary>
            Coefficient buffer control
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_c_main_controller">
            <summary>
            Main buffer control (downsampled-data buffer)
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_c_main_controller.process_data(System.Byte[][],System.Int32@,System.Int32)">
            <summary>
            Process some data.
            This routine handles the simple pass-through mode,
            where we have only a strip buffer.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_c_prep_controller">
            <summary>
            Compression preprocessing (downsampling input buffer control).
            
            For the simple (no-context-row) case, we just need to buffer one
            row group's worth of pixels for the downsampling step.  At the bottom of
            the image, we pad to a full row group by replicating the last pixel row.
            The downsampler's last output row is then replicated if needed to pad
            out to a full iMCU row.
            
            When providing context rows, we must buffer three row groups' worth of
            pixels.  Three row groups are physically allocated, but the row pointer
            arrays are made five row groups high, with the extra pointers above and
            below "wrapping around" to point to the last and first real row groups.
            This allows the downsampler to access the proper context rows.
            At the top and bottom of the image, we create dummy context rows by
            copying the first or last real pixel row.  This copying could be avoided
            by pointer hacking as is done in jdmainct.c, but it doesn't seem worth the
            trouble on the compression side.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_c_prep_controller.start_pass(BitMiracle.LibJpeg.Classic.Internal.J_BUF_MODE)">
            <summary>
            Initialize for a processing pass.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_c_prep_controller.create_context_buffer">
            <summary>
            Create the wrapped-around downsampling input buffer needed for context mode.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_c_prep_controller.pre_process_WithoutContext(System.Byte[][],System.Int32@,System.Int32,System.Byte[][][],System.Int32@,System.Int32)">
            <summary>
            Process some data in the simple no-context case.
            
            Preprocessor output data is counted in "row groups".  A row group
            is defined to be v_samp_factor sample rows of each component.
            Downsampling will produce this much data from each max_v_samp_factor
            input rows.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_c_prep_controller.pre_process_context(System.Byte[][],System.Int32@,System.Int32,System.Byte[][][],System.Int32@,System.Int32)">
            <summary>
            Process some data in the context case.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_c_prep_controller.expand_bottom_edge(System.Byte[][],System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Expand an image vertically from height input_rows to height output_rows,
            by duplicating the bottom row.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_decomp_master">
            <summary>
            Master control module
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_decomp_master.prepare_for_output_pass">
            <summary>
            Per-pass setup.
            This is called at the beginning of each output pass.  We determine which
            modules will be active during this pass and give them appropriate
            start_pass calls.  We also set is_dummy_pass to indicate whether this
            is a "real" output pass or a dummy pass for color quantization.
            (In the latter case, we will crank the pass to completion.)
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_decomp_master.finish_output_pass">
            <summary>
            Finish up at end of an output pass.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_decomp_master.master_selection">
            <summary>
            Master selection of decompression modules.
            This is done once at jpeg_start_decompress time.  We determine
            which modules will be used and give them appropriate initialization calls.
            We also initialize the decompressor input side to begin consuming data.
            
            Since jpeg_read_header has finished, we know what is in the SOF
            and (first) SOS markers.  We also have all the application parameter
            settings.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_decomp_master.prepare_range_limit_table">
            <summary>
            Allocate and fill in the sample_range_limit table.
            
            Several decompression processes need to range-limit values to the range
            0..MAXJSAMPLE; the input value may fall somewhat outside this range
            due to noise introduced by quantization, roundoff error, etc. These
            processes are inner loops and need to be as fast as possible. On most
            machines, particularly CPUs with pipelines or instruction prefetch,
            a (subscript-check-less) C table lookup
                x = sample_range_limit[x];
            is faster than explicit tests
            <c>
                if (x &amp; 0)
                   x = 0;
                else if (x > MAXJSAMPLE)
                   x = MAXJSAMPLE;
            </c>
            These processes all use a common table prepared by the routine below.
            
            For most steps we can mathematically guarantee that the initial value
            of x is within 2*(MAXJSAMPLE+1) of the legal range, so a table running
            from -2*(MAXJSAMPLE+1) to 3*MAXJSAMPLE+2 is sufficient.But for the
            initial limiting step(just after the IDCT), a wildly out-of-range value
            is possible if the input data is corrupt.To avoid any chance of indexing
            off the end of memory and getting a bad-pointer trap, we perform the
            post-IDCT limiting thus:
                <c>x = (sample_range_limit - SUBSET)[(x + CENTER) &amp; MASK];</c>
            where MASK is 2 bits wider than legal sample data, ie 10 bits for 8-bit
            samples.  Under normal circumstances this is more than enough range and
            a correct output will be generated; with bogus input data the mask will
            cause wraparound, and we will safely generate a bogus-but-in-range output.
            For the post-IDCT step, we want to convert the data from signed to unsigned
            representation by adding CENTERJSAMPLE at the same time that we limit it.
            This is accomplished with SUBSET = CENTER - CENTERJSAMPLE.
            
            Note that the table is allocated in near data space on PCs; it's small
            enough and used often enough to justify this.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_downsampler">
            <summary>
            Downsampling
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_downsampler.downsample(System.Byte[][][],System.Int32,System.Byte[][][],System.Int32)">
            <summary>
            Do downsampling for a whole row group (all components).
            
            In this version we simply downsample each component independently.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_downsampler.int_downsample(System.Int32,System.Byte[][],System.Int32,System.Byte[][],System.Int32)">
            <summary>
            Downsample pixel values of a single component.
            One row group is processed per call.
            This version handles arbitrary integral sampling ratios, without smoothing.
            Note that this version is not actually used for customary sampling ratios.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_downsampler.fullsize_downsample(System.Int32,System.Byte[][],System.Int32,System.Byte[][],System.Int32)">
            <summary>
            Downsample pixel values of a single component.
            This version handles the special case of a full-size component,
            without smoothing.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_downsampler.h2v1_downsample(System.Int32,System.Byte[][],System.Int32,System.Byte[][],System.Int32)">
            <summary>
            Downsample pixel values of a single component.
            This version handles the common case of 2:1 horizontal and 1:1 vertical,
            without smoothing.
            
            A note about the "bias" calculations: when rounding fractional values to
            integer, we do not want to always round 0.5 up to the next integer.
            If we did that, we'd introduce a noticeable bias towards larger values.
            Instead, this code is arranged so that 0.5 will be rounded up or down at
            alternate pixel locations (a simple ordered dither pattern).
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_downsampler.h2v2_downsample(System.Int32,System.Byte[][],System.Int32,System.Byte[][],System.Int32)">
            <summary>
            Downsample pixel values of a single component.
            This version handles the standard case of 2:1 horizontal and 2:1 vertical,
            without smoothing.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_downsampler.h2v2_smooth_downsample(System.Int32,System.Byte[][],System.Int32,System.Byte[][],System.Int32)">
            <summary>
            Downsample pixel values of a single component.
            This version handles the standard case of 2:1 horizontal and 2:1 vertical,
            with smoothing.  One row of context is required.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_downsampler.fullsize_smooth_downsample(System.Int32,System.Byte[][],System.Int32,System.Byte[][],System.Int32)">
            <summary>
            Downsample pixel values of a single component.
            This version handles the special case of a full-size component,
            with smoothing.  One row of context is required.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_downsampler.expand_right_edge(System.Byte[][],System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Expand a component horizontally from width input_cols to width output_cols,
            by duplicating the rightmost samples.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_coef_controller">
            <summary>
            Coefficient buffer control
            
            This code applies interblock smoothing as described by section K.8
            of the JPEG standard: the first 5 AC coefficients are estimated from
            the DC values of a DCT block and its 8 neighboring blocks.
            We apply smoothing only for progressive JPEG decoding, and only if
            the coefficients it can estimate are not yet known to full precision.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_coef_controller.start_input_pass">
            <summary>
            Initialize for an input processing pass.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_coef_controller.consume_data">
            <summary>
            Consume input data and store it in the full-image coefficient buffer.
            We read as much as one fully interleaved MCU row ("iMCU" row) per call,
            ie, v_samp_factor block rows for each component in the scan.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_coef_controller.start_output_pass">
            <summary>
            Initialize for an output processing pass.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_coef_controller.decompress_onepass(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[])">
            <summary>
            Decompress and return some data in the single-pass case.
            Always attempts to emit one fully interleaved MCU row ("iMCU" row).
            Input and output must run in lockstep since we have only a one-MCU buffer.
            Return value is JPEG_ROW_COMPLETED, JPEG_SCAN_COMPLETED, or JPEG_SUSPENDED.
            
            NB: output_buf contains a plane for each component in image,
            which we index according to the component's SOF position.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_coef_controller.decompress_data_ordinary(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[])">
            <summary>
            Decompress and return some data in the multi-pass case.
            Always attempts to emit one fully interleaved MCU row ("iMCU" row).
            Return value is JPEG_ROW_COMPLETED, JPEG_SCAN_COMPLETED, or JPEG_SUSPENDED.
            
            NB: output_buf contains a plane for each component in image.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_coef_controller.decompress_smooth_data(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[])">
            <summary>
            Variant of decompress_data for use when doing block smoothing.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_coef_controller.smoothing_ok">
            <summary>
            Determine whether block smoothing is applicable and safe.
            We also latch the current states of the coef_bits[] entries for the
            AC coefficients; otherwise, if the input side of the decompressor
            advances into a new scan, we might think the coefficients are known
            more accurately than they really are.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_coef_controller.start_iMCU_row">
            <summary>
            Reset within-iMCU-row counters for a new row (input side)
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_main_controller">
            <summary>
            Main buffer control (downsampled-data buffer)
            
            In the current system design, the main buffer need never be a full-image
            buffer; any full-height buffers will be found inside the coefficient or
            postprocessing controllers.  Nonetheless, the main controller is not
            trivial.  Its responsibility is to provide context rows for upsampling/
            rescaling, and doing this in an efficient fashion is a bit tricky.
            
            Postprocessor input data is counted in "row groups".  A row group
            is defined to be (v_samp_factor * DCT_scaled_size / min_DCT_scaled_size)
            sample rows of each component.  (We require DCT_scaled_size values to be
            chosen such that these numbers are integers.  In practice DCT_scaled_size
            values will likely be powers of two, so we actually have the stronger
            condition that DCT_scaled_size / min_DCT_scaled_size is an integer.)
            Upsampling will typically produce max_v_samp_factor pixel rows from each
            row group (times any additional scale factor that the upsampler is
            applying).
            
            The coefficient controller will deliver data to us one iMCU row at a time;
            each iMCU row contains v_samp_factor * DCT_scaled_size sample rows, or
            exactly min_DCT_scaled_size row groups.  (This amount of data corresponds
            to one row of MCUs when the image is fully interleaved.)  Note that the
            number of sample rows varies across components, but the number of row
            groups does not.  Some garbage sample rows may be included in the last iMCU
            row at the bottom of the image.
            
            Depending on the vertical scaling algorithm used, the upsampler may need
            access to the sample row(s) above and below its current input row group.
            The upsampler is required to set need_context_rows true at global selection
            time if so.  When need_context_rows is false, this controller can simply
            obtain one iMCU row at a time from the coefficient controller and dole it
            out as row groups to the postprocessor.
            
            When need_context_rows is true, this controller guarantees that the buffer
            passed to postprocessing contains at least one row group's worth of samples
            above and below the row group(s) being processed.  Note that the context
            rows "above" the first passed row group appear at negative row offsets in
            the passed buffer.  At the top and bottom of the image, the required
            context rows are manufactured by duplicating the first or last real sample
            row; this avoids having special cases in the upsampling inner loops.
            
            The amount of context is fixed at one row group just because that's a
            convenient number for this controller to work with.  The existing
            upsamplers really only need one sample row of context.  An upsampler
            supporting arbitrary output rescaling might wish for more than one row
            group of context when shrinking the image; tough, we don't handle that.
            (This is justified by the assumption that downsizing will be handled mostly
            by adjusting the DCT_scaled_size values, so that the actual scale factor at
            the upsample step needn't be much less than one.)
            
            To provide the desired context, we have to retain the last two row groups
            of one iMCU row while reading in the next iMCU row.  (The last row group
            can't be processed until we have another row group for its below-context,
            and so we have to save the next-to-last group too for its above-context.)
            We could do this most simply by copying data around in our buffer, but
            that'd be very slow.  We can avoid copying any data by creating a rather
            strange pointer structure.  Here's how it works.  We allocate a workspace
            consisting of M+2 row groups (where M = min_DCT_scaled_size is the number
            of row groups per iMCU row).  We create two sets of redundant pointers to
            the workspace.  Labeling the physical row groups 0 to M+1, the synthesized
            pointer lists look like this:
                              M+1                          M-1
                              master pointer --> 0         master pointer --> 0
                              1                            1
                              ...                          ...
                              M-3                          M-3
                              M-2                           M
                              M-1                          M+1
                               M                           M-2
                              M+1                          M-1
                               0                            0
            We read alternate iMCU rows using each master pointer; thus the last two
            row groups of the previous iMCU row remain un-overwritten in the workspace.
            The pointer lists are set up so that the required context rows appear to
            be adjacent to the proper places when we pass the pointer lists to the
            upsampler.
            
            The above pictures describe the normal state of the pointer lists.
            At top and bottom of the image, we diddle the pointer lists to duplicate
            the first or last sample row as necessary (this is cheaper than copying
            sample rows around).
            
            This scheme breaks down if M less than 2, ie, min_DCT_scaled_size is 1.  In that
            situation each iMCU row provides only one row group so the buffering logic
            must be different (eg, we must read two iMCU rows before we can emit the
            first row group).  For now, we simply do not support providing context
            rows when min_DCT_scaled_size is 1.  That combination seems unlikely to
            be worth providing --- if someone wants a 1/8th-size preview, they probably
            want it quick and dirty, so a context-free upsampler is sufficient.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_main_controller.start_pass(BitMiracle.LibJpeg.Classic.Internal.J_BUF_MODE)">
            <summary>
            Initialize for a processing pass.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_main_controller.process_data_simple_main(System.Byte[][],System.Int32@,System.Int32)">
            <summary>
            Process some data.
            This handles the simple case where no context is required.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_main_controller.process_data_context_main(System.Byte[][],System.Int32@,System.Int32)">
            <summary>
            Process some data.
            This handles the case where context rows must be provided.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_main_controller.process_data_crank_post(System.Byte[][],System.Int32@,System.Int32)">
            <summary>
            Process some data.
            Final pass of two-pass quantization: just call the postprocessor.
            Source data will be the postprocessor controller's internal buffer.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_main_controller.alloc_funny_pointers">
            <summary>
            Allocate space for the funny pointer lists.
            This is done only once, not once per pass.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_main_controller.make_funny_pointers">
            <summary>
            Create the funny pointer lists discussed in the comments above.
            The actual workspace is already allocated (in main.buffer),
            and the space for the pointer lists is allocated too.
            This routine just fills in the curiously ordered lists.
            This will be repeated at the beginning of each pass.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_main_controller.set_wraparound_pointers">
            <summary>
            Set up the "wraparound" pointers at top and bottom of the pointer lists.
            This changes the pointer list state from top-of-image to the normal state.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_main_controller.set_bottom_pointers">
            <summary>
            Change the pointer lists to duplicate the last sample row at the bottom
            of the image.  m_whichFunny indicates which m_funnyIndices holds the final iMCU row.
            Also sets rowgroups_avail to indicate number of nondummy row groups in row.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_post_controller">
            <summary>
            Decompression postprocessing (color quantization buffer control)
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_post_controller.#ctor(BitMiracle.LibJpeg.Classic.jpeg_decompress_struct,System.Boolean)">
            <summary>
            Initialize postprocessing controller.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_post_controller.start_pass(BitMiracle.LibJpeg.Classic.Internal.J_BUF_MODE)">
            <summary>
            Initialize for a processing pass.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_post_controller.post_process_1pass(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[],System.Int32@,System.Int32,System.Byte[][],System.Int32@,System.Int32)">
            <summary>
            Process some data in the one-pass (strip buffer) case.
            This is used for color precision reduction as well as one-pass quantization.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_post_controller.post_process_prepass(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[],System.Int32@,System.Int32,System.Int32@)">
            <summary>
            Process some data in the first pass of 2-pass quantization.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_post_controller.post_process_2pass(System.Byte[][],System.Int32@,System.Int32)">
            <summary>
            Process some data in the second pass of 2-pass quantization.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_entropy_decoder">
            <summary>
            Entropy decoding
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_entropy_encoder">
            <summary>
            Entropy encoding
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_forward_dct">
            <summary>
            Forward DCT (also controls coefficient quantization)
            
            A forward DCT routine is given a pointer to an input sample array and
            a pointer to a work area of type DCTELEM[]; the DCT is to be performed
            in-place in that buffer.  Type DCTELEM is int for 8-bit samples, INT32
            for 12-bit samples.  (NOTE: Floating-point DCT implementations use an
            array of type FAST_FLOAT, instead.)
            The input data is to be fetched from the sample array starting at a
            specified column.  (Any row offset needed will be applied to the array
            pointer before it is passed to the FDCT code.)
            Note that the number of samples fetched by the FDCT routine is
            DCT_h_scaled_size * DCT_v_scaled_size.
            The DCT outputs are returned scaled up by a factor of 8; they therefore
            have a range of +-8K for 8-bit data, +-128K for 12-bit data.  This
            convention improves accuracy in integer implementations and saves some
            work in floating-point ones.
            
            Each IDCT routine has its own ideas about the best dct_table element type.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_forward_dct.forward_DCT_ptr">
            <summary>
            Perform forward DCT on one or more blocks of a component.
            
            The input samples are taken from the sample_data[] array starting at
            position start_row/start_col, and moving to the right for any additional
            blocks. The quantized coefficients are returned in coef_blocks[].
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_forward_dct.start_pass">
            <summary>
            Initialize for a processing pass.
            Verify that all referenced Q-tables are present, and set up
            the divisor table for each one.
            In the current implementation, DCT of all components is done during
            the first pass, even if only some components will be output in the
            first scan.  Hence all components should be examined here.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_forward_dct.jpeg_fdct_float(System.Single[],System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Perform the forward DCT on one block of samples.
            NOTE: this code only copes with 8x8 DCTs.
            
            A floating-point implementation of the 
            forward DCT (Discrete Cosine Transform).
            
            This implementation should be more accurate than either of the integer
            DCT implementations.  However, it may not give the same results on all
            machines because of differences in roundoff behavior.  Speed will depend
            on the hardware's floating point capacity.
            
            A 2-D DCT can be done by 1-D DCT on each row followed by 1-D DCT
            on each column.  Direct algorithms are also available, but they are
            much more complex and seem not to be any faster when reduced to code.
            
            This implementation is based on Arai, Agui, and Nakajima's algorithm for
            scaled DCT.  Their original paper (Trans. IEICE E-71(11):1095) is in
            Japanese, but the algorithm is described in the Pennebaker &amp; Mitchell
            JPEG textbook (see REFERENCES section in file README).  The following code
            is based directly on figure 4-8 in P&amp;M.
            While an 8-point DCT cannot be done in less than 11 multiplies, it is
            possible to arrange the computation so that many of the multiplies are
            simple scalings of the final outputs.  These multiplies can then be
            folded into the multiplications or divisions by the JPEG quantization
            table entries.  The AA&amp;N method leaves only 5 multiplies and 29 adds
            to be done in the DCT itself.
            The primary disadvantage of this method is that with a fixed-point
            implementation, accuracy is lost due to imprecise representation of the
            scaled quantization values.  However, that problem does not arise if
            we use floating point arithmetic.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_forward_dct.jpeg_fdct_ifast(System.Int32[],System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Perform the forward DCT on one block of samples.
            NOTE: this code only copes with 8x8 DCTs.
            This file contains a fast, not so accurate integer implementation of the
            forward DCT (Discrete Cosine Transform).
            
            A 2-D DCT can be done by 1-D DCT on each row followed by 1-D DCT
            on each column.  Direct algorithms are also available, but they are
            much more complex and seem not to be any faster when reduced to code.
            
            This implementation is based on Arai, Agui, and Nakajima's algorithm for
            scaled DCT.  Their original paper (Trans. IEICE E-71(11):1095) is in
            Japanese, but the algorithm is described in the Pennebaker &amp; Mitchell
            JPEG textbook (see REFERENCES section in file README).  The following code
            is based directly on figure 4-8 in P&amp;M.
            While an 8-point DCT cannot be done in less than 11 multiplies, it is
            possible to arrange the computation so that many of the multiplies are
            simple scalings of the final outputs.  These multiplies can then be
            folded into the multiplications or divisions by the JPEG quantization
            table entries.  The AA&amp;N method leaves only 5 multiplies and 29 adds
            to be done in the DCT itself.
            The primary disadvantage of this method is that with fixed-point math,
            accuracy is lost due to imprecise representation of the scaled
            quantization values.  The smaller the quantization table entry, the less
            precise the scaled value, so this implementation does worse with high-
            quality-setting files than with low-quality ones.
            
            Scaling decisions are generally the same as in the LL&amp;M algorithm;
            see jpeg_fdct_islow for more details.  However, we choose to descale
            (right shift) multiplication products as soon as they are formed,
            rather than carrying additional fractional bits into subsequent additions.
            This compromises accuracy slightly, but it lets us save a few shifts.
            More importantly, 16-bit arithmetic is then adequate (for 8-bit samples)
            everywhere except in the multiplications proper; this saves a good deal
            of work on 16-bit-int machines.
            
            Again to save a few shifts, the intermediate results between pass 1 and
            pass 2 are not upscaled, but are represented only to integral precision.
            
            A final compromise is to represent the multiplicative constants to only
            8 fractional bits, rather than 13.  This saves some shifting work on some
            machines, and may also reduce the cost of multiplication (since there
            are fewer one-bits in the constants).
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_forward_dct.jpeg_fdct_islow(System.Int32[],System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Perform the forward DCT on one block of samples.
            NOTE: this code only copes with 8x8 DCTs.
            
            A slow-but-accurate integer implementation of the
            forward DCT (Discrete Cosine Transform).
            
            A 2-D DCT can be done by 1-D DCT on each row followed by 1-D DCT
            on each column.  Direct algorithms are also available, but they are
            much more complex and seem not to be any faster when reduced to code.
            
            This implementation is based on an algorithm described in
            C. Loeffler, A. Ligtenberg and G. Moschytz, "Practical Fast 1-D DCT
            Algorithms with 11 Multiplications", Proc. Int'l. Conf. on Acoustics,
            Speech, and Signal Processing 1989 (ICASSP '89), pp. 988-991.
            The primary algorithm described there uses 11 multiplies and 29 adds.
            We use their alternate method with 12 multiplies and 32 adds.
            The advantage of this method is that no data path contains more than one
            multiplication; this allows a very simple and accurate implementation in
            scaled fixed-point arithmetic, with a minimal number of shifts.
            
            The poop on this scaling stuff is as follows:
            
            Each 1-D DCT step produces outputs which are a factor of sqrt(N)
            larger than the true DCT outputs.  The final outputs are therefore
            a factor of N larger than desired; since N=8 this can be cured by
            a simple right shift at the end of the algorithm.  The advantage of
            this arrangement is that we save two multiplications per 1-D DCT,
            because the y0 and y4 outputs need not be divided by sqrt(N).
            In the IJG code, this factor of 8 is removed by the quantization 
            step, NOT here.
            
            We have to do addition and subtraction of the integer inputs, which
            is no problem, and multiplication by fractional constants, which is
            a problem to do in integer arithmetic.  We multiply all the constants
            by CONST_SCALE and convert them to integer constants (thus retaining
            SLOW_INTEGER_CONST_BITS bits of precision in the constants).  After doing a
            multiplication we have to divide the product by CONST_SCALE, with proper
            rounding, to produce the correct output.  This division can be done
            cheaply as a right shift of SLOW_INTEGER_CONST_BITS bits.  We postpone shifting
            as long as possible so that partial sums can be added together with
            full fractional precision.
            
            The outputs of the first pass are scaled up by SLOW_INTEGER_PASS1_BITS bits so that
            they are represented to better-than-integral precision.  These outputs
            require BITS_IN_JSAMPLE + SLOW_INTEGER_PASS1_BITS + 3 bits; this fits in a 16-bit word
            with the recommended scaling.  (For 12-bit sample data, the intermediate
            array is int anyway.)
            
            To avoid overflow of the 32-bit intermediate results in pass 2, we must
            have BITS_IN_JSAMPLE + SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS &lt;= 26.  Error analysis
            shows that the values given below are the most effective.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_forward_dct.FAST_INTEGER_MULTIPLY(System.Int32,System.Int32)">
            <summary>
            Multiply a DCTELEM variable by an int constant, and immediately
            descale to yield a DCTELEM result.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_input_controller">
            <summary>
            Input control module
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_input_controller.#ctor(BitMiracle.LibJpeg.Classic.jpeg_decompress_struct)">
            <summary>
            Initialize the input controller module.
            This is called only once, when the decompression object is created.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_input_controller.reset_input_controller">
            <summary>
            Reset state to begin a fresh datastream.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_input_controller.start_input_pass">
            <summary>
            Initialize the input modules to read a scan of compressed data.
            The first call to this is done after initializing
            the entire decompressor (during jpeg_start_decompress).
            Subsequent calls come from consume_markers, below.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_input_controller.finish_input_pass">
            <summary>
            Finish up after inputting a compressed-data scan.
            This is called by the coefficient controller after it's read all
            the expected data of the scan.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_input_controller.consume_markers">
            <summary>
            Read JPEG markers before, between, or after compressed-data scans.
            Change state as necessary when a new scan is reached.
            Return value is JPEG_SUSPENDED, JPEG_REACHED_SOS, or JPEG_REACHED_EOI.
            
            The consume_input method pointer points either here or to the
            coefficient controller's consume_data routine, depending on whether
            we are reading a compressed data segment or inter-segment markers.
            
            Note: This function should NOT return a pseudo SOS marker(with zero
            component number) to the caller.A pseudo marker received by
            read_markers is processed and then skipped for other markers.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_input_controller.initial_setup">
            <summary>
            Routines to calculate various quantities related to the size of the image.
            Called once, when first SOS marker is reached
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_input_controller.latch_quant_tables">
            <summary>
            Save away a copy of the Q-table referenced by each component present
            in the current scan, unless already saved during a prior scan.
            
            In a multiple-scan JPEG file, the encoder could assign different components
            the same Q-table slot number, but change table definitions between scans
            so that each component uses a different Q-table.  (The IJG encoder is not
            currently capable of doing this, but other encoders might.)  Since we want
            to be able to dequantize all the components at the end of the file, this
            means that we have to save away the table actually used for each component.
            We do this by copying the table at the start of the first scan containing
            the component.
            The JPEG spec prohibits the encoder from changing the contents of a Q-table
            slot between scans of a component using that slot.  If the encoder does so
            anyway, this decoder will simply use the Q-table values that were current
            at the start of the first scan for the component.
            
            The decompressor output side looks only at the saved quant tables,
            not at the current Q-table slots.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_input_controller.per_scan_setup">
            <summary>
            Do computations that are needed before processing a JPEG scan
            cinfo.comps_in_scan and cinfo.cur_comp_info[] were set from SOS marker
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_inverse_dct">
            <summary>
            An inverse DCT routine is given a pointer to the input JBLOCK and a pointer
            to an output sample array.  The routine must dequantize the input data as
            well as perform the IDCT; for dequantization, it uses the multiplier table
            pointed to by componentInfo.dct_table.  The output data is to be placed into the
            sample array starting at a specified column. (Any row offset needed will
            be applied to the array pointer before it is passed to the IDCT code)
            Note that the number of samples emitted by the IDCT routine is
            DCT_h_scaled_size * DCT_v_scaled_size.
            
            Each IDCT routine has its own ideas about the best dct_table element type.
            
            The decompressor input side saves away the appropriate
            quantization table for each component at the start of the first scan
            involving that component.  (This is necessary in order to correctly
            decode files that reuse Q-table slots.)
            When we are ready to make an output pass, the saved Q-table is converted
            to a multiplier table that will actually be used by the IDCT routine.
            The multiplier table contents are IDCT-method-dependent.  To support
            application changes in IDCT method between scans, we can remake the
            multiplier tables if necessary.
            In buffered-image mode, the first output pass may occur before any data
            has been seen for some components, and thus before their Q-tables have
            been saved away.  To handle this case, multiplier tables are preset
            to zeroes; the result of the IDCT will be a neutral gray level.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_inverse_dct.start_pass">
            <summary>
            Prepare for an output pass.
            Here we select the proper IDCT routine for each component and build
            a matching multiplier table.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_inverse_dct.jpeg_idct_islow(System.Int32,System.Int16[],System.Int32,System.Int32)">
            <summary>
            Perform dequantization and inverse DCT on one block of coefficients.
            NOTE: this code only copes with 8x8 DCTs.
            A slow-but-accurate integer implementation of the
            inverse DCT (Discrete Cosine Transform).  In the IJG code, this routine
            must also perform dequantization of the input coefficients.
            
            A 2-D IDCT can be done by 1-D IDCT on each column followed by 1-D IDCT
            on each row (or vice versa, but it's more convenient to emit a row at
            a time).  Direct algorithms are also available, but they are much more
            complex and seem not to be any faster when reduced to code.
            
            This implementation is based on an algorithm described in
            C. Loeffler, A. Ligtenberg and G. Moschytz, "Practical Fast 1-D DCT
            Algorithms with 11 Multiplications", Proc. Int'l. Conf. on Acoustics,
            Speech, and Signal Processing 1989 (ICASSP '89), pp. 988-991.
            The primary algorithm described there uses 11 multiplies and 29 adds.
            We use their alternate method with 12 multiplies and 32 adds.
            The advantage of this method is that no data path contains more than one
            multiplication; this allows a very simple and accurate implementation in
            scaled fixed-point arithmetic, with a minimal number of shifts.
            
            The poop on this scaling stuff is as follows:
            
            Each 1-D IDCT step produces outputs which are a factor of sqrt(N)
            larger than the true IDCT outputs.  The final outputs are therefore
            a factor of N larger than desired; since N=8 this can be cured by
            a simple right shift at the end of the algorithm.  The advantage of
            this arrangement is that we save two multiplications per 1-D IDCT,
            because the y0 and y4 inputs need not be divided by sqrt(N).
            
            We have to do addition and subtraction of the integer inputs, which
            is no problem, and multiplication by fractional constants, which is
            a problem to do in integer arithmetic.  We multiply all the constants
            by CONST_SCALE and convert them to integer constants (thus retaining
            SLOW_INTEGER_CONST_BITS bits of precision in the constants).  After doing a
            multiplication we have to divide the product by CONST_SCALE, with proper
            rounding, to produce the correct output.  This division can be done
            cheaply as a right shift of SLOW_INTEGER_CONST_BITS bits.  We postpone shifting
            as long as possible so that partial sums can be added together with
            full fractional precision.
            
            The outputs of the first pass are scaled up by SLOW_INTEGER_PASS1_BITS bits so that
            they are represented to better-than-integral precision.  These outputs
            require BITS_IN_JSAMPLE + SLOW_INTEGER_PASS1_BITS + 3 bits; this fits in a 16-bit word
            with the recommended scaling.  (To scale up 12-bit sample data further, an
            intermediate int array would be needed.)
            
            To avoid overflow of the 32-bit intermediate results in pass 2, we must
            have BITS_IN_JSAMPLE + SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS &lt;= 26.  Error analysis
            shows that the values given below are the most effective.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_inverse_dct.jpeg_idct_ifast(System.Int32,System.Int16[],System.Int32,System.Int32)">
            <summary>
            Perform dequantization and inverse DCT on one block of coefficients.
            NOTE: this code only copes with 8x8 DCTs.
            
            A fast, not so accurate integer implementation of the
            inverse DCT (Discrete Cosine Transform).  In the IJG code, this routine
            must also perform dequantization of the input coefficients.
            
            A 2-D IDCT can be done by 1-D IDCT on each column followed by 1-D IDCT
            on each row (or vice versa, but it's more convenient to emit a row at
            a time).  Direct algorithms are also available, but they are much more
            complex and seem not to be any faster when reduced to code.
            
            This implementation is based on Arai, Agui, and Nakajima's algorithm for
            scaled DCT.  Their original paper (Trans. IEICE E-71(11):1095) is in
            Japanese, but the algorithm is described in the Pennebaker &amp; Mitchell
            JPEG textbook (see REFERENCES section in file README).  The following code
            is based directly on figure 4-8 in P&amp;M.
            While an 8-point DCT cannot be done in less than 11 multiplies, it is
            possible to arrange the computation so that many of the multiplies are
            simple scalings of the final outputs.  These multiplies can then be
            folded into the multiplications or divisions by the JPEG quantization
            table entries.  The AA&amp;N method leaves only 5 multiplies and 29 adds
            to be done in the DCT itself.
            The primary disadvantage of this method is that with fixed-point math,
            accuracy is lost due to imprecise representation of the scaled
            quantization values.  The smaller the quantization table entry, the less
            precise the scaled value, so this implementation does worse with high-
            quality-setting files than with low-quality ones.
            
            Scaling decisions are generally the same as in the LL&amp;M algorithm;
            However, we choose to descale
            (right shift) multiplication products as soon as they are formed,
            rather than carrying additional fractional bits into subsequent additions.
            This compromises accuracy slightly, but it lets us save a few shifts.
            More importantly, 16-bit arithmetic is then adequate (for 8-bit samples)
            everywhere except in the multiplications proper; this saves a good deal
            of work on 16-bit-int machines.
            
            The dequantized coefficients are not integers because the AA&amp;N scaling
            factors have been incorporated.  We represent them scaled up by FAST_INTEGER_PASS1_BITS,
            so that the first and second IDCT rounds have the same input scaling.
            For 8-bit JSAMPLEs, we choose IFAST_SCALE_BITS = FAST_INTEGER_PASS1_BITS so as to
            avoid a descaling shift; this compromises accuracy rather drastically
            for small quantization table entries, but it saves a lot of shifts.
            For 12-bit JSAMPLEs, there's no hope of using 16x16 multiplies anyway,
            so we use a much larger scaling factor to preserve accuracy.
            
            A final compromise is to represent the multiplicative constants to only
            8 fractional bits, rather than 13.  This saves some shifting work on some
            machines, and may also reduce the cost of multiplication (since there
            are fewer one-bits in the constants).
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_inverse_dct.FAST_INTEGER_MULTIPLY(System.Int32,System.Int32)">
            <summary>
            Multiply a DCTELEM variable by an int constant, and immediately
            descale to yield a DCTELEM result.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_inverse_dct.FAST_INTEGER_DEQUANTIZE(System.Int16,System.Int32)">
            <summary>
            Dequantize a coefficient by multiplying it by the multiplier-table
            entry; produce a DCTELEM result.  For 8-bit data a 16x16->16
            multiplication will do.  For 12-bit data, the multiplier table is
            declared int, so a 32-bit multiply will be used.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_inverse_dct.FAST_INTEGER_IRIGHT_SHIFT(System.Int32,System.Int32)">
            <summary>
            Like DESCALE, but applies to a DCTELEM and produces an int.
            We assume that int right shift is unsigned if int right shift is.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_inverse_dct.jpeg_idct_float(System.Int32,System.Int16[],System.Int32,System.Int32)">
            <summary>
            Perform dequantization and inverse DCT on one block of coefficients.
            NOTE: this code only copes with 8x8 DCTs.
            
            A floating-point implementation of the
            inverse DCT (Discrete Cosine Transform).  In the IJG code, this routine
            must also perform dequantization of the input coefficients.
            
            This implementation should be more accurate than either of the integer
            IDCT implementations.  However, it may not give the same results on all
            machines because of differences in roundoff behavior.  Speed will depend
            on the hardware's floating point capacity.
            
            A 2-D IDCT can be done by 1-D IDCT on each column followed by 1-D IDCT
            on each row (or vice versa, but it's more convenient to emit a row at
            a time).  Direct algorithms are also available, but they are much more
            complex and seem not to be any faster when reduced to code.
            
            This implementation is based on Arai, Agui, and Nakajima's algorithm for
            scaled DCT.  Their original paper (Trans. IEICE E-71(11):1095) is in
            Japanese, but the algorithm is described in the Pennebaker &amp; Mitchell
            JPEG textbook (see REFERENCES section in file README).  The following code
            is based directly on figure 4-8 in P&amp;M.
            While an 8-point DCT cannot be done in less than 11 multiplies, it is
            possible to arrange the computation so that many of the multiplies are
            simple scalings of the final outputs.  These multiplies can then be
            folded into the multiplications or divisions by the JPEG quantization
            table entries.  The AA&amp;N method leaves only 5 multiplies and 29 adds
            to be done in the DCT itself.
            The primary disadvantage of this method is that with a fixed-point
            implementation, accuracy is lost due to imprecise representation of the
            scaled quantization values.  However, that problem does not arise if
            we use floating point arithmetic.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_inverse_dct.FLOAT_DEQUANTIZE(System.Int16,System.Single)">
            <summary>
            Dequantize a coefficient by multiplying it by the multiplier-table
            entry; produce a float result.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_inverse_dct.jpeg_idct_4x4(System.Int32,System.Int16[],System.Int32,System.Int32)">
            <summary>
            Inverse-DCT routines that produce reduced-size output:
            either 4x4, 2x2, or 1x1 pixels from an 8x8 DCT block.
            
            NOTE: this code only copes with 8x8 DCTs.
            
            The implementation is based on the Loeffler, Ligtenberg and Moschytz (LL&amp;M)
            algorithm. We simply replace each 8-to-8 1-D IDCT step
            with an 8-to-4 step that produces the four averages of two adjacent outputs
            (or an 8-to-2 step producing two averages of four outputs, for 2x2 output).
            These steps were derived by computing the corresponding values at the end
            of the normal LL&amp;M code, then simplifying as much as possible.
            
            1x1 is trivial: just take the DC coefficient divided by 8.
            
            Perform dequantization and inverse DCT on one block of coefficients,
            producing a reduced-size 4x4 output block.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_inverse_dct.jpeg_idct_2x2(System.Int32,System.Int16[],System.Int32,System.Int32)">
            <summary>
            Perform dequantization and inverse DCT on one block of coefficients,
            producing a reduced-size 2x2 output block.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_inverse_dct.jpeg_idct_1x1(System.Int32,System.Int16[],System.Int32,System.Int32)">
            <summary>
            Perform dequantization and inverse DCT on one block of coefficients,
            producing a reduced-size 1x1 output block.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_inverse_dct.REDUCED_DEQUANTIZE(System.Int16,System.Int32)">
            <summary>
            Dequantize a coefficient by multiplying it by the multiplier-table
            entry; produce an int result.  In this module, both inputs and result
            are 16 bits or less, so either int or short multiply will work.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader">
            <summary>
            Marker reading and parsing
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.#ctor(BitMiracle.LibJpeg.Classic.jpeg_decompress_struct)">
            <summary>
            Initialize the marker reader module.
            This is called only once, when the decompression object is created.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.reset_marker_reader">
            <summary>
            Reset marker processing state to begin a fresh datastream.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.read_markers">
            <summary>
            Read markers until SOS or EOI.
            
            Returns same codes as are defined for jpeg_consume_input:
            JPEG_SUSPENDED, JPEG_REACHED_SOS, or JPEG_REACHED_EOI.
            
            Note: This function may return a pseudo SOS marker(with zero
            component number) for treat by input controller's consume_input.
            consume_input itself should filter out (skip) the pseudo marker
            after processing for the caller.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.read_restart_marker">
            <summary>
            Read a restart marker, which is expected to appear next in the datastream;
            if the marker is not there, take appropriate recovery action.
            Returns false if suspension is required.
            
            Made public for use by entropy decoder only
            
            This is called by the entropy decoder after it has read an appropriate
            number of MCUs.  cinfo.unread_marker may be nonzero if the entropy decoder
            has already read a marker from the data source.  Under normal conditions
            cinfo.unread_marker will be reset to 0 before returning; if not reset,
            it holds a marker which the decoder will be unable to read past.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.next_marker">
            <summary>
            Find the next JPEG marker, save it in cinfo.unread_marker.
            Returns false if had to suspend before reaching a marker;
            in that case cinfo.unread_marker is unchanged.
            
            Note that the result might not be a valid marker code,
            but it will never be 0 or FF.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.jpeg_set_marker_processor(System.Int32,BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_marker_parser_method)">
            <summary>
            Install a special processing method for COM or APPn markers.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.save_marker(BitMiracle.LibJpeg.Classic.jpeg_decompress_struct)">
            <summary>
            Save an APPn or COM marker into the marker list
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.skip_variable(BitMiracle.LibJpeg.Classic.jpeg_decompress_struct)">
            <summary>
            Skip over an unknown or uninteresting variable-length marker
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.get_interesting_appn(BitMiracle.LibJpeg.Classic.jpeg_decompress_struct)">
            <summary>
            Process an APP0 or APP14 marker without saving it
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.examine_app0(BitMiracle.LibJpeg.Classic.jpeg_decompress_struct,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Examine first few bytes from an APP0.
            Take appropriate action if it is a JFIF marker.
            datalen is # of bytes at data[], remaining is length of rest of marker data.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.examine_app14(BitMiracle.LibJpeg.Classic.jpeg_decompress_struct,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Examine first few bytes from an APP14.
            Take appropriate action if it is an Adobe marker.
            datalen is # of bytes at data[], remaining is length of rest of marker data.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.get_soi">
            <summary>
            Process an SOI marker
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.get_sof(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Process a SOFn marker
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.get_sos">
            <summary>
            Process a SOS marker
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.get_dac">
            <summary>
            Process a DAC marker
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.get_dht">
            <summary>
            Process a DHT marker
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.get_dqt">
            <summary>
            Process a DQT marker
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.get_dri">
            <summary>
            Process a DRI marker
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.get_lse">
            <summary>
            Process an LSE marker
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.first_marker">
            <summary>
            Like next_marker, but used to obtain the initial SOI marker.
            For this marker, we do not allow preceding garbage or fill; otherwise,
            we might well scan an entire input file before realizing it ain't JPEG.
            If an application wants to process non-JFIF files, it must seek to the
            SOI before calling the JPEG library.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer">
            <summary>
            Marker writing
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.write_file_header">
            <summary>
            Write datastream header.
            This consists of an SOI and optional APPn markers.
            We recommend use of the JFIF marker, but not the Adobe marker,
            when using YCbCr or grayscale data. The JFIF marker is also used
            for other standard JPEG colorspaces. The Adobe marker is helpful
            to distinguish RGB, CMYK, and YCCK colorspaces.
            Note that an application can write additional header markers after
            jpeg_start_compress returns.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.write_frame_header">
            <summary>
            Write frame header.
            This consists of DQT and SOFn markers,
            a conditional LSE marker and a conditional pseudo SOS marker.
            Note that we do not emit the SOF until we have emitted the DQT(s).
            This avoids compatibility problems with incorrect implementations that
            try to error-check the quant table numbers as soon as they see the SOF.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.write_scan_header">
            <summary>
            Write scan header.
            This consists of DHT or DAC markers, optional DRI, and SOS.
            Compressed data will be written following the SOS.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.write_file_trailer">
            <summary>
            Write datastream trailer.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.write_tables_only">
            <summary>
            Write an abbreviated table-specification datastream.
            This consists of SOI, DQT and DHT tables, and EOI.
            Any table that is defined and not marked sent_table = true will be
            emitted.  Note that all tables will be marked sent_table = true at exit.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.write_marker_header(System.Int32,System.Int32)">
            <summary>
            Emit an arbitrary marker header
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.write_marker_byte(System.Byte)">
            <summary>
            Emit one byte of marker parameters following write_marker_header
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.emit_sos">
            <summary>
            Emit a SOS marker
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.emit_lse_ict">
            <summary>
            Emit an LSE inverse color transform specification marker
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.emit_sof(BitMiracle.LibJpeg.Classic.JPEG_MARKER)">
            <summary>
            Emit a SOF marker
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.emit_adobe_app14">
            <summary>
            Emit an Adobe APP14 marker
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.emit_dri">
            <summary>
            Emit a DRI marker
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.emit_dht(System.Int32,System.Boolean)">
            <summary>
            Emit a DHT marker
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.emit_dqt(System.Int32)">
            <summary>
            Emit a DQT marker
            </summary>
            <param name="index">The index.</param>
            <returns>the precision used (0 = 8bits, 1 = 16bits) for baseline checking</returns>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.emit_pseudo_sos">
            <summary>
            Emit a pseudo SOS marker
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.emit_jfif_app0">
            <summary>
            Emit a JFIF-compliant APP0 marker
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.emit_marker(BitMiracle.LibJpeg.Classic.JPEG_MARKER)">
            <summary>
            Emit a marker code
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.emit_2bytes(System.Int32)">
            <summary>
            Emit a 2-byte integer; these are always MSB first in JPEG files
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.emit_byte(System.Int32)">
            <summary>
            Emit a byte
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_scan_info">
            <summary>
            The script for encoding a multiple-scan file is an array of these:
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_upsampler">
            <summary>
            Upsampling (note that upsampler must also call color converter)
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.J_BUF_MODE">
            <summary>
            Operating modes for buffer controllers
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer">
            <summary>
            The main purpose of 1-pass quantization is to provide a fast, if not very
            high quality, colormapped output capability.  A 2-pass quantizer usually
            gives better visual quality; however, for quantized grayscale output this
            quantizer is perfectly adequate.  Dithering is highly recommended with this
            quantizer, though you can turn it off if you really want to.
            
            In 1-pass quantization the colormap must be chosen in advance of seeing the
            image.  We use a map consisting of all combinations of Ncolors[i] color
            values for the i'th component.  The Ncolors[] values are chosen so that
            their product, the total number of colors, is no more than that requested.
            (In most cases, the product will be somewhat less.)
            
            Since the colormap is orthogonal, the representative value for each color
            component can be determined without considering the other components;
            then these indexes can be combined into a colormap index by a standard
            N-dimensional-array-subscript calculation.  Most of the arithmetic involved
            can be precalculated and stored in the lookup table colorindex[].
            colorindex[i][j] maps pixel value j in component i to the nearest
            representative value (grid plane) for that component; this index is
            multiplied by the array stride for component i, so that the
            index of the colormap entry closest to a given pixel value is just
                sum( colorindex[component-number][pixel-component-value] )
            Aside from being fast, this scheme allows for variable spacing between
            representative values with no additional lookup cost.
            
            If gamma correction has been applied in color conversion, it might be wise
            to adjust the color grid spacing so that the representative colors are
            equidistant in linear space.  At this writing, gamma correction is not
            implemented, so nothing is done here.
            
            
            Declarations for Floyd-Steinberg dithering.
            
            Errors are accumulated into the array fserrors[], at a resolution of
            1/16th of a pixel count.  The error at a given pixel is propagated
            to its not-yet-processed neighbors using the standard F-S fractions,
                ...	(here)	7/16
               3/16	5/16	1/16
            We work left-to-right on even rows, right-to-left on odd rows.
            
            We can get away with a single array (holding one row's worth of errors)
            by using it to store the current row's errors at pixel columns not yet
            processed, but the next row's errors at columns already processed.  We
            need only a few extra variables to hold the errors immediately around the
            current column.  (If we are lucky, those variables are in registers, but
            even if not, they're probably cheaper to access than array elements are.)
            
            The fserrors[] array is indexed [component#][position].
            We provide (#columns + 2) entries per component; the extra entry at each
            end saves us from special-casing the first and last pixels.
            
            
            Declarations for ordered dithering.
            
            We use a standard 16x16 ordered dither array.  The basic concept of ordered
            dithering is described in many references, for instance Dale Schumacher's
            chapter II.2 of Graphics Gems II (James Arvo, ed. Academic Press, 1991).
            In place of Schumacher's comparisons against a "threshold" value, we add a
            "dither" value to the input pixel and then round the result to the nearest
            output value.  The dither value is equivalent to (0.5 - threshold) times
            the distance between output values.  For ordered dithering, we assume that
            the output colors are equally spaced; if not, results will probably be
            worse, since the dither may be too much or too little at a given point.
            
            The normal calculation would be to form pixel value + dither, range-limit
            this to 0..MAXJSAMPLE, and then index into the colorindex table as usual.
            We can skip the separate range-limiting step by extending the colorindex
            table in both directions.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.#ctor(BitMiracle.LibJpeg.Classic.jpeg_decompress_struct)">
            <summary>
            Module initialization routine for 1-pass color quantization.
            </summary>
            <param name="cinfo">The cinfo.</param>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.start_pass(System.Boolean)">
            <summary>
            Initialize for one-pass color quantization.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.finish_pass">
            <summary>
            Finish up at the end of the pass.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.new_color_map">
            <summary>
            Switch to a new external colormap between output passes.
            Shouldn't get to this!
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.quantize(System.Byte[][],System.Int32,System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Map some rows of pixels to the output colormapped representation.
            General case, no dithering.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.quantize3(System.Byte[][],System.Int32,System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Map some rows of pixels to the output colormapped representation.
            Fast path for out_color_components==3, no dithering
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.quantize_ord_dither(System.Byte[][],System.Int32,System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Map some rows of pixels to the output colormapped representation.
            General case, with ordered dithering.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.quantize3_ord_dither(System.Byte[][],System.Int32,System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Map some rows of pixels to the output colormapped representation.
            Fast path for out_color_components==3, with ordered dithering
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.quantize_fs_dither(System.Byte[][],System.Int32,System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Map some rows of pixels to the output colormapped representation.
            General case, with Floyd-Steinberg dithering
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.create_colormap">
            <summary>
            Create the colormap.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.create_colorindex">
            <summary>
            Create the color index table.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.create_odither_tables">
            <summary>
            Create the ordered-dither tables.
            Components having the same number of representative colors may 
            share a dither table.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.alloc_fs_workspace">
            <summary>
            Allocate workspace for Floyd-Steinberg errors.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.largest_input_value(System.Int32,System.Int32)">
            <summary>
            Return largest input value that should map to j'th output value
            Must have largest(j=0) >= 0, and largest(j=maxj) >= MAXJSAMPLE
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.output_value(System.Int32,System.Int32)">
            <summary>
            Return j'th output value, where j will range from 0 to maxj
            The output values must fall in 0..MAXJSAMPLE in increasing order
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.select_ncolors(System.Int32[])">
            <summary>
            Determine allocation of desired colors to components,
            and fill in Ncolors[] array to indicate choice.
            Return value is total number of colors (product of Ncolors[] values).
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.make_odither_array(System.Int32)">
            <summary>
            Create an ordered-dither array for a component having ncolors
            distinct output values.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer">
            <summary>
            This module implements the well-known Heckbert paradigm for color
            quantization.  Most of the ideas used here can be traced back to
            Heckbert's seminal paper
            Heckbert, Paul.  "Color Image Quantization for Frame Buffer Display",
            Proc. SIGGRAPH '82, Computer Graphics v.16 #3 (July 1982), pp 297-304.
            
            In the first pass over the image, we accumulate a histogram showing the
            usage count of each possible color.  To keep the histogram to a reasonable
            size, we reduce the precision of the input; typical practice is to retain
            5 or 6 bits per color, so that 8 or 4 different input values are counted
            in the same histogram cell.
            
            Next, the color-selection step begins with a box representing the whole
            color space, and repeatedly splits the "largest" remaining box until we
            have as many boxes as desired colors.  Then the mean color in each
            remaining box becomes one of the possible output colors.
            
            The second pass over the image maps each input pixel to the closest output
            color (optionally after applying a Floyd-Steinberg dithering correction).
            This mapping is logically trivial, but making it go fast enough requires
            considerable care.
            
            Heckbert-style quantizers vary a good deal in their policies for choosing
            the "largest" box and deciding where to cut it.  The particular policies
            used here have proved out well in experimental comparisons, but better ones
            may yet be found.
            
            In earlier versions of the IJG code, this module quantized in YCbCr color
            space, processing the raw upsampled data without a color conversion step.
            This allowed the color conversion math to be done only once per colormap
            entry, not once per pixel.  However, that optimization precluded other
            useful optimizations (such as merging color conversion with upsampling)
            and it also interfered with desired capabilities such as quantizing to an
            externally-supplied colormap.  We have therefore abandoned that approach.
            The present code works in the post-conversion color space, typically RGB.
            
            To improve the visual quality of the results, we actually work in scaled
            RGB space, giving G distances more weight than R, and R in turn more than
            B.  To do everything in integer math, we must use integer scale factors.
            The 2/3/1 scale factors used here correspond loosely to the relative
            weights of the colors in the NTSC grayscale equation.
            If you want to use this code to quantize a non-RGB color space, you'll
            probably need to change these scale factors.
            
            First we have the histogram data structure and routines for creating it.
            
            The number of bits of precision can be adjusted by changing these symbols.
            We recommend keeping 6 bits for G and 5 each for R and B.
            If you have plenty of memory and cycles, 6 bits all around gives marginally
            better results; if you are short of memory, 5 bits all around will save
            some space but degrade the results.
            To maintain a fully accurate histogram, we'd need to allocate a "long"
            (preferably unsigned long) for each cell.  In practice this is overkill;
            we can get by with 16 bits per cell.  Few of the cell counts will overflow,
            and clamping those that do overflow to the maximum value will give close-
            enough results.  This reduces the recommended histogram size from 256Kb
            to 128Kb, which is a useful savings on PC-class machines.
            (In the second pass the histogram space is re-used for pixel mapping data;
            in that capacity, each cell must be able to store zero to the number of
            desired colors.  16 bits/cell is plenty for that too.)
            Since the JPEG code is intended to run in small memory model on 80x86
            machines, we can't just allocate the histogram in one chunk.  Instead
            of a true 3-D array, we use a row of pointers to 2-D arrays.  Each
            pointer corresponds to a C0 value (typically 2^5 = 32 pointers) and
            each 2-D array has 2^6*2^5 = 2048 or 2^6*2^6 = 4096 entries.  Note that
            on 80x86 machines, the pointer row is in near memory but the actual
            arrays are in far memory (same arrangement as we use for image arrays).
            
            
            Declarations for Floyd-Steinberg dithering.
            
            Errors are accumulated into the array fserrors[], at a resolution of
            1/16th of a pixel count.  The error at a given pixel is propagated
            to its not-yet-processed neighbors using the standard F-S fractions,
                ... (here)  7/16
            3/16    5/16    1/16
            We work left-to-right on even rows, right-to-left on odd rows.
            
            We can get away with a single array (holding one row's worth of errors)
            by using it to store the current row's errors at pixel columns not yet
            processed, but the next row's errors at columns already processed.  We
            need only a few extra variables to hold the errors immediately around the
            current column.  (If we are lucky, those variables are in registers, but
            even if not, they're probably cheaper to access than array elements are.)
            
            The fserrors[] array has (#columns + 2) entries; the extra entry at
            each end saves us from special-casing the first and last pixels.
            Each entry is three values long, one value for each color component.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.#ctor(BitMiracle.LibJpeg.Classic.jpeg_decompress_struct)">
            <summary>
            Module initialization routine for 2-pass color quantization.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.start_pass(System.Boolean)">
            <summary>
            Initialize for each processing pass.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.new_color_map">
            <summary>
            Switch to a new external colormap between output passes.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.prescan_quantize(System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Prescan some rows of pixels.
            In this module the prescan simply updates the histogram, which has been
            initialized to zeroes by start_pass.
            An output_buf parameter is required by the method signature, but no data
            is actually output (in fact the buffer controller is probably passing a
            null pointer).
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.pass2_fs_dither(System.Byte[][],System.Int32,System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Map some rows of pixels to the output colormapped representation.
            This version performs Floyd-Steinberg dithering
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.pass2_no_dither(System.Byte[][],System.Int32,System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Map some rows of pixels to the output colormapped representation.
            This version performs no dithering
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.finish_pass1">
            <summary>
            Finish up at the end of each pass.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.compute_color(BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.box[],System.Int32,System.Int32)">
            <summary>
            Compute representative color for a box, put it in colormap[icolor]
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.select_colors(System.Int32)">
            <summary>
            Master routine for color selection
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.median_cut(BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.box[],System.Int32,System.Int32)">
            <summary>
            Repeatedly select and split the largest box until we have enough boxes
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.find_biggest_color_pop(BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.box[],System.Int32)">
            <summary>
            Find the splittable box with the largest color population
            Returns null if no splittable boxes remain
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.find_biggest_volume(BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.box[],System.Int32)">
            <summary>
            Find the splittable box with the largest (scaled) volume
            Returns null if no splittable boxes remain
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.update_box(BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.box[],System.Int32)">
            <summary>
            Shrink the min/max bounds of a box to enclose only nonzero elements,
            and recompute its volume and population
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.init_error_limit">
            <summary>
            Initialize the error-limiting transfer function (lookup table).
            The raw F-S error computation can potentially compute error values of up to
            +- MAXJSAMPLE.  But we want the maximum correction applied to a pixel to be
            much less, otherwise obviously wrong pixels will be created.  (Typical
            effects include weird fringes at color-area boundaries, isolated bright
            pixels in a dark area, etc.)  The standard advice for avoiding this problem
            is to ensure that the "corners" of the color cube are allocated as output
            colors; then repeated errors in the same direction cannot cause cascading
            error buildup.  However, that only prevents the error from getting
            completely out of hand; Aaron Giles reports that error limiting improves
            the results even with corner colors allocated.
            A simple clamping of the error values to about +- MAXJSAMPLE/8 works pretty
            well, but the smoother transfer function used below is even better.  Thanks
            to Aaron Giles for this idea.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.find_nearby_colors(System.Int32,System.Int32,System.Int32,System.Byte[])">
            <summary>
            Locate the colormap entries close enough to an update box to be candidates
            for the nearest entry to some cell(s) in the update box.  The update box
            is specified by the center coordinates of its first cell.  The number of
            candidate colormap entries is returned, and their colormap indexes are
            placed in colorlist[].
            This routine uses Heckbert's "locally sorted search" criterion to select
            the colors that need further consideration.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.find_best_colors(System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Byte[])">
            <summary>
            Find the closest colormap entry for each cell in the update box,
            given the list of candidate colors prepared by find_nearby_colors.
            Return the indexes of the closest entries in the bestcolor[] array.
            This routine uses Thomas' incremental distance calculation method to
            find the distance from a colormap entry to successive cells in the box.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.fill_inverse_cmap(System.Int32,System.Int32,System.Int32)">
            <summary>
            Fill the inverse-colormap entries in the update box that contains
            histogram cell c0/c1/c2.  (Only that one cell MUST be filled, but
            we can fill as many others as we wish.)
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_c_coef_controller.compressDataImpl(System.Byte[][][])">
            <summary>
            Process some data in the single-pass case.
            We process the equivalent of one fully interleaved MCU row ("iMCU" row)
            per call, ie, v_samp_factor block rows for each component in the image.
            Returns true if the iMCU row is completed, false if suspended.
            
            NB: input_buf contains a plane for each component in image,
            which we index according to the component's SOF position.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_c_coef_controller.compressFirstPass(System.Byte[][][])">
            <summary>
            Process some data in the first pass of a multi-pass case.
            We process the equivalent of one fully interleaved MCU row ("iMCU" row)
            per call, ie, v_samp_factor block rows for each component in the image.
            This amount of data is read from the source buffer, DCT'd and quantized,
            and saved into the virtual arrays.  We also generate suitable dummy blocks
            as needed at the right and lower edges.  (The dummy blocks are constructed
            in the virtual arrays, which have been padded appropriately.)  This makes
            it possible for subsequent passes not to worry about real vs. dummy blocks.
            
            We must also emit the data to the entropy encoder.  This is conveniently
            done by calling compress_output() after we've loaded the current strip
            of the virtual arrays.
            
            NB: input_buf contains a plane for each component in image.  All
            components are DCT'd and loaded into the virtual arrays in this pass.
            However, it may be that only a subset of the components are emitted to
            the entropy encoder during this first pass; be careful about looking
            at the scan-dependent variables (MCU dimensions, etc).
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_c_coef_controller.compressOutput">
            <summary>
            Process some data in subsequent passes of a multi-pass case.
            We process the equivalent of one fully interleaved MCU row ("iMCU" row)
            per call, ie, v_samp_factor block rows for each component in the scan.
            The data is obtained from the virtual arrays and fed to the entropy coder.
            Returns true if the iMCU row is completed, false if suspended.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.my_destination_mgr">
            <summary>
            Expanded data destination object for output to Stream
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_destination_mgr.init_destination">
            <summary>
            Initialize destination --- called by jpeg_start_compress
            before any data is actually written.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_destination_mgr.empty_output_buffer">
            <summary>
            Empty the output buffer --- called whenever buffer fills up.
            
            In typical applications, this should write the entire output buffer
            (ignoring the current state of next_output_byte and free_in_buffer),
            reset the pointer and count to the start of the buffer, and return true
            indicating that the buffer has been dumped.
            
            In applications that need to be able to suspend compression due to output
            overrun, a false return indicates that the buffer cannot be emptied now.
            In this situation, the compressor will return to its caller (possibly with
            an indication that it has not accepted all the supplied scanlines).  The
            application should resume compression after it has made more room in the
            output buffer.  Note that there are substantial restrictions on the use of
            suspension --- see the documentation.
            
            When suspending, the compressor will back up to a convenient restart point
            (typically the start of the current MCU). next_output_byte and free_in_buffer
            indicate where the restart point will be if the current call returns false.
            Data beyond this point will be regenerated after resumption, so do not
            write it out when emptying the buffer externally.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_destination_mgr.term_destination">
            <summary>
            Terminate destination --- called by jpeg_finish_compress
            after all data has been written.  Usually needs to flush buffer.
            
            NB: *not* called by jpeg_abort or jpeg_destroy; surrounding
            application must deal with any cleanup that should happen even
            for error exit.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_merged_upsampler.start_pass">
            <summary>
            Initialize for an upsampling pass.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_merged_upsampler.merged_1v_upsample(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[],System.Int32@,System.Byte[][],System.Int32@)">
            <summary>
            Control routine to do upsampling (and color conversion).
            The control routine just handles the row buffering considerations.
            1:1 vertical sampling case: much easier, never need a spare row.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_merged_upsampler.merged_2v_upsample(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[],System.Int32@,System.Byte[][],System.Int32@,System.Int32)">
            <summary>
            Control routine to do upsampling (and color conversion).
            The control routine just handles the row buffering considerations.
            2:1 vertical sampling case: may need a spare row.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_merged_upsampler.h2v1_merged_upsample(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[],System.Int32,System.Byte[][],System.Int32)">
            <summary>
            Upsample and color convert for the case of 2:1 horizontal and 1:1 vertical.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_merged_upsampler.h2v2_merged_upsample(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[],System.Int32,System.Byte[][])">
            <summary>
            Upsample and color convert for the case of 2:1 horizontal and 2:1 vertical.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_merged_upsampler.build_ycc_rgb_table">
            <summary>
            Initialize tables for YCbCr->RGB colorspace conversion.
            This is taken directly from jpeg_color_deconverter; see that file for more info.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_merged_upsampler.build_bg_ycc_rgb_table">
            <summary>
            Initialize tables for BG_YCC->RGB colorspace conversion.
            This is taken directly from jpeg_color_deconverter; see that file for more info.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.my_source_mgr">
            <summary>
            Expanded data source object for stdio input
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_source_mgr.#ctor(BitMiracle.LibJpeg.Classic.jpeg_decompress_struct)">
            <summary>
            Initialize source - called by jpeg_read_header
            before any data is actually read.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_source_mgr.fill_input_buffer">
            <summary>
            Fill the input buffer - called whenever buffer is emptied.
            
            In typical applications, this should read fresh data into the buffer
            (ignoring the current state of next_input_byte and bytes_in_buffer),
            reset the pointer and count to the start of the buffer, and return true
            indicating that the buffer has been reloaded.  It is not necessary to
            fill the buffer entirely, only to obtain at least one more byte.
            
            There is no such thing as an EOF return.  If the end of the file has been
            reached, the routine has a choice of ERREXIT() or inserting fake data into
            the buffer.  In most cases, generating a warning message and inserting a
            fake EOI marker is the best course of action --- this will allow the
            decompressor to output however much of the image is there.  However,
            the resulting error message is misleading if the real problem is an empty
            input file, so we handle that case specially.
            
            In applications that need to be able to suspend compression due to input
            not being available yet, a false return indicates that no more data can be
            obtained right now, but more may be forthcoming later.  In this situation,
            the decompressor will return to its caller (with an indication of the
            number of scanlines it has read, if any).  The application should resume
            decompression after it has loaded more data into the input buffer.  Note
            that there are substantial restrictions on the use of suspension --- see
            the documentation.
            
            When suspending, the decompressor will back up to a convenient restart point
            (typically the start of the current MCU). next_input_byte and bytes_in_buffer
            indicate where the restart point will be if the current call returns false.
            Data beyond this point must be rescanned after resumption, so move it to
            the front of the buffer rather than discarding it.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.my_trans_c_coef_controller">
            <summary>
            This is a special implementation of the coefficient
            buffer controller.  This is similar to jccoefct.c, but it handles only
            output from presupplied virtual arrays.  Furthermore, we generate any
            dummy padding blocks on-the-fly rather than expecting them to be present
            in the arrays.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_trans_c_coef_controller.#ctor(BitMiracle.LibJpeg.Classic.jpeg_compress_struct,BitMiracle.LibJpeg.Classic.jvirt_array{BitMiracle.LibJpeg.Classic.JBLOCK}[])">
            <summary>
            Initialize coefficient buffer controller.
            
            Each passed coefficient array must be the right size for that
            coefficient: width_in_blocks wide and height_in_blocks high,
            with unit height at least v_samp_factor.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_trans_c_coef_controller.start_pass(BitMiracle.LibJpeg.Classic.Internal.J_BUF_MODE)">
            <summary>
            Initialize for a processing pass.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_trans_c_coef_controller.compress_data(System.Byte[][][])">
            <summary>
            Process some data.
            We process the equivalent of one fully interleaved MCU row ("iMCU" row)
            per call, ie, v_samp_factor block rows for each component in the scan.
            The data is obtained from the virtual arrays and fed to the entropy coder.
            Returns true if the iMCU row is completed, false if suspended.
            
            NB: input_buf is ignored; it is likely to be a null pointer.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_trans_c_coef_controller.start_iMCU_row">
            <summary>
            Reset within-iMCU-row counters for a new row
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_upsampler.start_pass">
            <summary>
            Initialize for an upsampling pass.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_upsampler.upsample(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[],System.Int32@,System.Int32,System.Byte[][],System.Int32@,System.Int32)">
            <summary>
            Control routine to do upsampling (and color conversion).
            
            In this version we upsample each component independently.
            We upsample one row group into the conversion buffer, then apply
            color conversion a row at a time.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_upsampler.noop_upsample">
            <summary>
            This is a no-op version used for "uninteresting" components.
            These components will not be referenced by color conversion.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_upsampler.fullsize_upsample(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer)">
            <summary>
            For full-size components, we just make color_buf[ci] point at the
            input buffer, and thus avoid copying any data.  Note that this is
            safe only because sep_upsample doesn't declare the input row group
            "consumed" until we are done color converting and emitting it.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_upsampler.h2v1_upsample(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer)">
            <summary>
            Fast processing for the common case of 2:1 horizontal and 1:1 vertical.
            It's still a box filter.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_upsampler.h2v2_upsample(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer)">
            <summary>
            Fast processing for the common case of 2:1 horizontal and 2:1 vertical.
            It's still a box filter.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_upsampler.int_upsample(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer)">
            <summary>
            This version handles any integral sampling ratios.
            This is not used for typical JPEG files, so it need not be fast.
            Nor, for that matter, is it particularly accurate: the algorithm is
            simple replication of the input pixel onto the corresponding output
            pixels.  The hi-falutin sampling literature refers to this as a
            "box filter".  A box filter tends to introduce visible artifacts,
            so if you are actually going to use 3:1 or 4:1 sampling ratios
            you would be well advised to improve this code.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.JBLOCK">
            <summary>
            One block of coefficients.
            </summary>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.JBLOCK.Item(System.Int32)">
            <summary>
            Gets or sets the element at the specified index.
            </summary>
            <param name="index">The index of required element.</param>
            <value>The required element.</value>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.JHUFF_TBL">
            <summary>
            Huffman coding table.
            </summary>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.JHUFF_TBL.Sent_table">
            <summary>
            Gets or sets a value indicating whether the table has been output to file.
            </summary>
            <value>It's initialized <c>false</c> when the table is created, and set 
            <c>true</c> when it's been output to the file. You could suppress output 
            of a table by setting this to <c>true</c>.
            </value>
            <remarks>This property is used only during compression. It's initialized
            <c>false</c> when the table is created, and set <c>true</c> when it's been
            output to the file. You could suppress output of a table by setting this to
            <c>true</c>. (See jpeg_suppress_tables for an example.)</remarks>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_suppress_tables(System.Boolean)"/>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.JpegConstants">
            <summary>
            Defines some JPEG constants.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.DCTSIZE">
            <summary>
            The basic DCT block is 8x8 coefficients
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.DCTSIZE2">
            <summary>
            DCTSIZE squared; the number of elements in a block. 
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.NUM_QUANT_TBLS">
            <summary>
            Quantization tables are numbered 0..3 
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.NUM_HUFF_TBLS">
            <summary>
            Huffman tables are numbered 0..3
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.NUM_ARITH_TBLS">
            <summary>
            Arith-coding tables are numbered 0..15
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.MAX_COMPS_IN_SCAN">
            <summary>
            JPEG limit on the number of components in one scan.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.C_MAX_BLOCKS_IN_MCU">
            <summary>
            Compressor's limit on blocks per MCU.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.D_MAX_BLOCKS_IN_MCU">
            <summary>
            Decompressor's limit on blocks per MCU.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.MAX_SAMP_FACTOR">
            <summary>
            JPEG limit on sampling factors.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.MAX_COMPONENTS">
            <summary>
            Maximum number of color channels allowed in JPEG image.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.BITS_IN_JSAMPLE">
            <summary>
            The size of sample.
            </summary>
            <remarks>Are either:
            8 - for 8-bit sample values (the usual setting)<br/>
            9 - for 9-bit sample values
            10 - for 10-bit sample values
            11 - for 11-bit sample values
            12 - for 12-bit sample values (not supported by this version)<br/>
            Only 8, 9, 10, 11, and 12 bits sample data precision are supported for
            full-feature DCT processing.Further depths up to 16-bit may be added
            later for the lossless modes of operation.
            Run-time selection and conversion of data precision will be added later
            and are currently not supported, sorry.
            Exception:  The transcoding part(jpegtran) supports all settings in a
            single instance, since it operates on the level of DCT coefficients and
            not sample values.The DCT coefficients are of the same type(16 bits)
            in all cases(see below).
            </remarks>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.JDCT_DEFAULT">
            <summary>
            DCT method used by default.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.JDCT_FASTEST">
            <summary>
            Fastest DCT method.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.JPEG_MAX_DIMENSION">
            <summary>
            A tad under 64K to prevent overflows. 
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.MAXJSAMPLE">
            <summary>
            The maximum sample value.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.CENTERJSAMPLE">
            <summary>
            The medium sample value.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.RGB_RED">
            <summary>
            Offset of Red in an RGB scanline element. 
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.RGB_GREEN">
            <summary>
            Offset of Green in an RGB scanline element. 
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.RGB_BLUE">
            <summary>
            Offset of Blue in an RGB scanline element. 
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.RGB_PIXELSIZE">
            <summary>
            Bytes per RGB scanline element.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.HUFF_LOOKAHEAD">
            <summary>
            The number of bits of lookahead.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.jpeg_common_struct">
            <summary>Base class for both JPEG compressor and decompresor.</summary>
            <remarks>
            Routines that are to be used by both halves of the library are declared
            to receive an instance of this class. There are no actual instances of 
            <see cref="T:BitMiracle.LibJpeg.Classic.jpeg_common_struct"/>, only of <see cref="T:BitMiracle.LibJpeg.Classic.jpeg_compress_struct"/> 
            and <see cref="T:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct"/>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.#ctor">
            <summary>
            Base constructor.
            </summary>
            <seealso cref="T:BitMiracle.LibJpeg.Classic.jpeg_compress_struct"/>
            <seealso cref="T:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct"/>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.#ctor(BitMiracle.LibJpeg.Classic.jpeg_error_mgr)">
            <summary>
            Base constructor.
            </summary>
            <param name="errorManager">The error manager.</param>
            <seealso cref="T:BitMiracle.LibJpeg.Classic.jpeg_compress_struct"/>
            <seealso cref="T:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct"/>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_common_struct.IsDecompressor">
            <summary>
            Gets a value indicating whether this instance is Jpeg decompressor.
            </summary>
            <value>
            	<c>true</c> if this is Jpeg decompressor; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_common_struct.Progress">
            <summary>
            Progress monitor.
            </summary>
            <value>The progress manager.</value>
            <remarks>Default value: <c>null</c>.</remarks>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_common_struct.Err">
            <summary>
            Error handler module.
            </summary>
            <value>The error manager.</value>
            <seealso href="41dc1a3b-0dea-4594-87d2-c213ab1049e1.htm" target="_self">Error handling</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_common_struct.Version">
            <summary>
            Gets the version of LibJpeg.
            </summary>
            <value>The version of LibJpeg.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_common_struct.Copyright">
            <summary>
            Gets the LibJpeg's copyright.
            </summary>
            <value>The copyright.</value>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.CreateSamplesArray(System.Int32,System.Int32)">
            <summary>
            Creates the array of samples.
            </summary>
            <param name="samplesPerRow">The number of samples in row.</param>
            <param name="numberOfRows">The number of rows.</param>
            <returns>The array of samples.</returns>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.CreateBlocksArray(System.Int32,System.Int32)">
            <summary>
            Creates the array of blocks.
            </summary>
            <param name="blocksPerRow">The number of blocks in row.</param>
            <param name="numberOfRows">The number of rows.</param>
            <returns>The array of blocks.</returns>
            <seealso cref="T:BitMiracle.LibJpeg.Classic.JBLOCK"/>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.AllocJpegSamples(System.Int32,System.Int32)">
            <summary>
            Creates 2-D sample array.
            </summary>
            <param name="samplesPerRow">The number of samples per row.</param>
            <param name="numberOfRows">The number of rows.</param>
            <returns>The array of samples.</returns>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.jpeg_abort">
            <summary>
            Abort processing of a JPEG compression or decompression operation,
            but don't destroy the object itself.
            
            Closing a data source or destination, if necessary, is the 
            application's responsibility.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.jpeg_destroy">
            <summary>
            Destruction of a JPEG object. 
            
            Closing a data source or destination, if necessary, is the 
            application's responsibility.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.ERREXIT(BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE)">
            <summary>
            Used for fatal errors (print message and exit).
            </summary>
            <param name="code">The message code.</param>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.ERREXIT(BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE,System.Object[])">
            <summary>
            Used for fatal errors (print message and exit).
            </summary>
            <param name="code">The message code.</param>
            <param name="args">The parameters of message.</param>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.ERREXIT(System.Int32,System.Object[])">
            <summary>
            Used for fatal errors (print message and exit).
            </summary>
            <param name="code">The message code.</param>
            <param name="args">The parameters of message.</param>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.WARNMS(BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE)">
            <summary>
            Used for non-fatal errors (we can keep going, but the data is probably corrupt).
            </summary>
            <param name="code">The message code.</param>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.WARNMS(BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE,System.Object[])">
            <summary>
            Used for non-fatal errors (we can keep going, but the data is probably corrupt).
            </summary>
            <param name="code">The message code.</param>
            <param name="args">The parameters of message.</param>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.WARNMS(System.Int32,System.Object[])">
            <summary>
            Used for non-fatal errors (we can keep going, but the data is probably corrupt).
            </summary>
            <param name="code">The message code.</param>
            <param name="args">The parameters of message.</param>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.TRACEMS(System.Int32,BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE)">
            <summary>
            Shows informational and debugging messages.
            </summary>
            <param name="lvl">See <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.emit_message(System.Int32)"/> for description.</param>
            <param name="code">The message code.</param>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.emit_message(System.Int32)"/>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.TRACEMS(System.Int32,BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE,System.Object[])">
            <summary>
            Shows informational and debugging messages.
            </summary>
            <param name="lvl">See <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.emit_message(System.Int32)"/> for description.</param>
            <param name="code">The message code.</param>
            <param name="args">The parameters of message.</param>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.emit_message(System.Int32)"/>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.TRACEMS(System.Int32,System.Int32,System.Object[])">
            <summary>
            Shows informational and debugging messages.
            </summary>
            <param name="lvl">See <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.emit_message(System.Int32)"/> for description.</param>
            <param name="code">The message code.</param>
            <param name="args">The parameters of message.</param>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.emit_message(System.Int32)"/>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.jpeg_component_info">
            <summary>
            Basic info about one component (color channel).
            </summary>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_component_info.Component_id">
            <summary>
            Identifier for this component (0..255)
            </summary>
            <value>The component ID.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_component_info.Component_index">
            <summary>
            Its index in SOF or <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Comp_info"/>.
            </summary>
            <value>The component index.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_component_info.H_samp_factor">
            <summary>
            Horizontal sampling factor (1..4)
            </summary>
            <value>The horizontal sampling factor.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_component_info.V_samp_factor">
            <summary>
            Vertical sampling factor (1..4)
            </summary>
            <value>The vertical sampling factor.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_component_info.Quant_tbl_no">
            <summary>
            Quantization table selector (0..3)
            </summary>
            <value>The quantization table selector.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_component_info.Dc_tbl_no">
            <summary>
            DC entropy table selector (0..3)
            </summary>
            <value>The DC entropy table selector.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_component_info.Ac_tbl_no">
            <summary>
            AC entropy table selector (0..3)
            </summary>
            <value>The AC entropy table selector.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_component_info.Width_in_blocks">
            <summary>
            Gets or sets the width in blocks.
            </summary>
            <value>The width in blocks.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_component_info.Downsampled_width">
            <summary>
            Gets the downsampled width.
            </summary>
            <value>The downsampled width.</value>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.jpeg_compress_struct">
            <summary>
            JPEG compression routine.
            </summary>
            <seealso cref="T:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct"/>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.scale_num">
            <summary>
            The scale numerator
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.scale_denom">
            <summary>
            The scale denomenator
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.q_scale_factor">
            <summary>
            corresponding scale factors (percentage, initialized 100).
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.do_fancy_downsampling">
            <summary>
            TRUE=apply fancy downsampling
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.color_transform">
            <summary>
            Color transform identifier, writes LSE marker if nonzero
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.block_size">
            <summary>
            the basic DCT block size: 1..16
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:BitMiracle.LibJpeg.Classic.jpeg_compress_struct"/> class.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.#ctor(BitMiracle.LibJpeg.Classic.jpeg_error_mgr)">
            <summary>
            Initializes a new instance of the <see cref="T:BitMiracle.LibJpeg.Classic.jpeg_compress_struct"/> class.
            </summary>
            <param name="errorManager">The error manager.</param>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.IsDecompressor">
            <summary>
            Retrieves <c>false</c> because this is not decompressor.
            </summary>
            <value><c>false</c></value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Dest">
            <summary>
            Gets or sets the destination for compressed data
            </summary>
            <value>The destination for compressed data.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Image_width">
            <summary>
            Gets or sets the width of image, in pixels.
            </summary>
            <value>The width of image.</value>
            <seealso href="../articles/KB/compression-details.html">Compression details</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Image_height">
            <summary>
            Gets or sets the height of image, in pixels.
            </summary>
            <value>The height of image.</value>
            <seealso href="../articles/KB/compression-details.html">Compression details</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Input_components">
            <summary>
            Gets or sets the number of color channels (components per pixel)
            </summary>
            <value>The number of color channels.</value>
            <seealso href="../articles/KB/compression-details.html">Compression details</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.In_color_space">
            <summary>
            Gets or sets the color space of source image.
            </summary>
            <value>The color space.</value>
            <seealso href="../articles/KB/compression-details.html">Compression details</seealso>
            <seealso href="../articles/KB/special-color-spaces.html">Special color spaces</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Data_precision">
            <summary>
            Gets or sets the number of bits of precision in image data.
            </summary>
            <remarks>Default value: 8<br/>
            The number of bits.
            </remarks>
            <value>The data precision.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Num_components">
            <summary>
            Gets or sets the number of color components for JPEG color space.
            </summary>
            <value>The number of color components for JPEG color space.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Jpeg_color_space">
            <summary>
            Gets or sets the JPEG color space.
            </summary>
            <remarks>We recommend to use <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_set_colorspace(BitMiracle.LibJpeg.Classic.J_COLOR_SPACE)"/> if you want to change this.</remarks>
            <value>The JPEG color space.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Raw_data_in">
            <summary>
            Gets or sets a value indicating whether you will be supplying raw data.
            </summary>
            <remarks>Default value: <c>false</c></remarks>
            <value><c>true</c> if you will be supplying raw data; otherwise, <c>false</c>.</value>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_raw_data(System.Byte[][][],System.Int32)"/>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Optimize_coding">
            <summary>
            Gets or sets a value indicating a way of using Huffman coding tables.
            </summary>
            <remarks>When this is <c>true</c>, you need not supply Huffman tables at all, and any you do supply will be overwritten.</remarks>
            <value><c>true</c> causes the compressor to compute optimal Huffman coding tables 
            for the image. This requires an extra pass over the data and therefore costs a good 
            deal of space and time. The default is <c>false</c>, which tells the compressor to use the 
            supplied or default Huffman tables. In most cases optimal tables save only a few 
            percent of file size compared to the default tables.</value>
            <seealso href="../articles/KB/compression-parameter-selection.html">Compression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.CCIR601_sampling">
            <summary>
            Gets or sets a value indicating whether first samples are cosited.
            </summary>
            <value><c>true</c> if first samples are cosited; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Smoothing_factor">
            <summary>
            Gets or sets the coefficient of image smoothing.
            </summary>
            <remarks>Default value: 0<br/>
            If non-zero, the input image is smoothed; the value should be 1 for minimal smoothing 
            to 100 for maximum smoothing.</remarks>
            <value>The coefficient of image smoothing.</value>
            <seealso href="../articles/KB/compression-parameter-selection.html">Compression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Dct_method">
            <summary>
            Gets or sets the algorithm used for the DCT step.
            </summary>
            <value>The DCT algorithm.</value>
            <seealso href="../articles/KB/compression-parameter-selection.html">Compression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Restart_interval">
            <summary>
            Gets or sets the exact interval in MCU blocks.
            </summary>
            <remarks>Default value: 0<br/>
            One restart marker per MCU row is often a good choice. The overhead of restart markers 
            is higher in grayscale JPEG files than in color files, and MUCH higher in progressive JPEGs. 
            If you use restarts, you may want to use larger intervals in those cases.</remarks>
            <value>The restart interval.</value>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Restart_in_rows"/>
            <seealso href="../articles/KB/compression-parameter-selection.html">Compression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Restart_in_rows">
            <summary>
            Gets or sets the interval in MCU rows.
            </summary>
            <remarks>Default value: 0<br/>
            If Restart_in_rows is not 0, then <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Restart_interval"/> is set 
            after the image width in MCUs is computed.<br/>
            One restart marker per MCU row is often a good choice. 
            The overhead of restart markers is higher in grayscale JPEG files than in color files, and MUCH higher in progressive JPEGs. If you use restarts, you may want to use larger intervals in those cases.
            </remarks>
            <value>The restart interval in MCU rows.</value>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Restart_interval"/>
            <seealso href="../articles/KB/compression-parameter-selection.html">Compression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Write_JFIF_header">
            <summary>
            Gets or sets a value indicating whether the JFIF APP0 marker is emitted.
            </summary>
            <remarks><see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_set_defaults"/> and 
            <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_set_colorspace(BitMiracle.LibJpeg.Classic.J_COLOR_SPACE)"/> set this <c>true</c> 
            if a JFIF-legal JPEG color space (i.e., YCbCr or grayscale) is selected, otherwise <c>false</c>.</remarks>
            <value><c>true</c> if JFIF APP0 marker is emitted; otherwise, <c>false</c>.</value>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.JFIF_major_version"/>
            <seealso href="../articles/KB/compression-parameter-selection.html">Compression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.JFIF_major_version">
            <summary>
            Gets or sets the version number to be written into the JFIF marker.
            </summary>
            <remarks><see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_set_defaults"/> initializes the version to 
            1.01 (major=minor=1). You should set it to 1.02 (major=1, minor=2) if you plan to write any 
            JFIF 1.02 extension markers.</remarks>
            <value>The version number to be written into the JFIF marker.</value>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.JFIF_minor_version"/>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Write_JFIF_header"/>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.JFIF_minor_version">
            <summary>
            Gets or sets the version number to be written into the JFIF marker.
            </summary>
            <remarks><see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_set_defaults"/> initializes the version to 
            1.01 (major=minor=1). You should set it to 1.02 (major=1, minor=2) if you plan to write any 
            JFIF 1.02 extension markers.</remarks>
            <value>The version number to be written into the JFIF marker.</value>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.JFIF_major_version"/>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Write_JFIF_header"/>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Density_unit">
            <summary>
            Gets or sets the resolution information to be written into the JFIF marker; not used otherwise.
            </summary>
            <remarks>Default value: <see cref="F:BitMiracle.LibJpeg.Classic.DensityUnit.Unknown"/><br/>
            The pixel aspect ratio is defined by 
            <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.X_density"/>/<see cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Y_density"/> 
            even when Density_unit is <see cref="F:BitMiracle.LibJpeg.Classic.DensityUnit.Unknown">Unknown</see>.</remarks>
            <value>The density unit.</value>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.X_density"/>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Y_density"/>
            <seealso href="../articles/KB/compression-parameter-selection.html">Compression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.X_density">
            <summary>
            Gets or sets the horizontal component of pixel ratio.
            </summary>
            <remarks>Default value: 1</remarks>
            <value>The horizontal density.</value>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Density_unit"/>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Y_density"/>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Y_density">
            <summary>
            Gets or sets the vertical component of pixel ratio.
            </summary>
            <remarks>Default value: 1</remarks>
            <value>The vertical density.</value>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Density_unit"/>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.X_density"/>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Write_Adobe_marker">
            <summary>
            Gets or sets a value indicating whether to emit Adobe APP14 marker.
            </summary>
            <remarks><see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_set_defaults"/> and <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_set_colorspace(BitMiracle.LibJpeg.Classic.J_COLOR_SPACE)"/> 
            set this <c>true</c> if JPEG color space RGB, CMYK, or YCCK is selected, otherwise <c>false</c>. 
            It is generally a bad idea to set both <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Write_JFIF_header"/> and 
            <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Write_Adobe_marker"/>. 
            In fact, you probably shouldn't change the default settings at all - the default behavior ensures that the JPEG file's 
            color space can be recognized by the decoder.</remarks>
            <value>If <c>true</c> an Adobe APP14 marker is emitted; <c>false</c>, otherwise.</value>
            <seealso href="../articles/KB/compression-parameter-selection.html">Compression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Max_v_samp_factor">
            <summary>
            Gets the largest vertical sample factor.
            </summary>
            <value>The largest vertical sample factor.</value>
            <seealso href="../articles/KB/compression-parameter-selection.html">Compression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Component_info">
            <summary>
            Gets the components that appears in SOF.
            </summary>
            <value>The component info array.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Quant_tbl_ptrs">
            <summary>
            Gets the coefficient quantization tables.
            </summary>
            <value>The coefficient quantization tables or null if not defined.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Dc_huff_tbl_ptrs">
            <summary>
            Gets the Huffman coding tables.
            </summary>
            <value>The Huffman coding tables or null if not defined.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Ac_huff_tbl_ptrs">
            <summary>
            Gets the Huffman coding tables.
            </summary>
            <value>The Huffman coding tables or null if not defined.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Next_scanline">
            <summary>
            Gets the index of next scanline to be written to <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_scanlines(System.Byte[][],System.Int32)"/>.
            </summary>
            <remarks>Application may use this to control its processing loop, 
            e.g., "while (Next_scanline &lt; Image_height)"</remarks>
            <value>Range: from 0 to (Image_height - 1)</value>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_scanlines(System.Byte[][],System.Int32)"/>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_abort_compress">
            <summary>
            Abort processing of a JPEG compression operation.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_suppress_tables(System.Boolean)">
            <summary>
            Forcibly suppress or un-suppress all quantization and Huffman tables.
            </summary>
            <remarks>Marks all currently defined tables as already written (if suppress)
            or not written (if !suppress). This will control whether they get 
            emitted by a subsequent <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_start_compress(System.Boolean)"/> call.<br/>
            
            This routine is exported for use by applications that want to produce
            abbreviated JPEG datastreams.</remarks>
            <param name="suppress">if set to <c>true</c> then suppress tables; 
            otherwise unsuppress.</param>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_finish_compress">
            <summary>
            Finishes JPEG compression.
            </summary>
            <remarks>If a multipass operating mode was selected, this may do a great 
            deal of work including most of the actual output.</remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_marker(System.Int32,System.Byte[])">
            <summary>
            Write a special marker.
            </summary>
            <remarks>This is only recommended for writing COM or APPn markers. 
            Must be called after <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_start_compress(System.Boolean)"/> and before first call to 
            <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_scanlines(System.Byte[][],System.Int32)"/> or <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_raw_data(System.Byte[][][],System.Int32)"/>.
            </remarks>
            <param name="marker">Specify the marker type parameter as <see cref="T:BitMiracle.LibJpeg.Classic.JPEG_MARKER"/>.COM for COM or 
            <see cref="T:BitMiracle.LibJpeg.Classic.JPEG_MARKER"/>.APP0 + n for APPn. (Actually, jpeg_write_marker will let you write any marker type, 
            but we don't recommend writing any other kinds of marker)</param>
            <param name="data">The data associated with the marker.</param>
            <seealso href="../articles/KB/special-markers.html">Special markers</seealso>
            <seealso cref="T:BitMiracle.LibJpeg.Classic.JPEG_MARKER"/>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_m_header(System.Int32,System.Int32)">
            <summary>
            Writes special marker's header.
            </summary>
            <param name="marker">Special marker.</param>
            <param name="datalen">Length of data associated with the marker.</param>
            <remarks>After calling this method you need to call <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_m_byte(System.Byte)"/>
            exactly the number of times given in the length parameter.<br/>
            This method lets you empty the output buffer partway through a marker, which might be important when 
            using a suspending data destination module. In any case, if you are using a suspending destination, 
            you should flush its buffer after inserting any special markers.</remarks>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_m_byte(System.Byte)"/>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_marker(System.Int32,System.Byte[])"/>
            <seealso href="../articles/KB/special-markers.html">Special markers</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_m_byte(System.Byte)">
            <summary>
            Writes a byte of special marker's data.
            </summary>
            <param name="val">The byte of data.</param>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_m_header(System.Int32,System.Int32)"/>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_tables">
            <summary>
            Alternate compression function: just write an abbreviated table file.
            </summary>
            <remarks>Before calling this, all parameters and a data destination must be set up.<br/>
            
            To produce a pair of files containing abbreviated tables and abbreviated
            image data, one would proceed as follows:<br/>
            
            <c>Initialize JPEG object<br/>
            Set JPEG parameters<br/>
            Set destination to table file<br/>
            <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_tables">jpeg_write_tables();</see><br/>
            Set destination to image file<br/>
            <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_start_compress(System.Boolean)">jpeg_start_compress(false);</see><br/>
            Write data...<br/>
            <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_finish_compress">jpeg_finish_compress();</see><br/>
            </c><br/>
            
            jpeg_write_tables has the side effect of marking all tables written
            (same as <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_suppress_tables(System.Boolean)">jpeg_suppress_tables(true)</see>).
            Thus a subsequent <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_start_compress(System.Boolean)">jpeg_start_compress</see> 
            will not re-emit the tables unless it is passed <c>write_all_tables=true</c>.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_stdio_dest(System.IO.Stream)">
            <summary>
            Sets output stream.
            </summary>
            <param name="outfile">The output stream.</param>
            <remarks>The caller must have already opened the stream, and is responsible
            for closing it after finishing compression.</remarks>
            <seealso href="../articles/KB/compression-details.html">Compression details</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_set_defaults">
            <summary>
            Jpeg_set_defaultses this instance.
            </summary>
            <remarks>Uses only the input image's color space (property <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.In_color_space"/>, 
            which must already be set in <see cref="T:BitMiracle.LibJpeg.Classic.jpeg_compress_struct"/>). Many applications will only need 
            to use this routine and perhaps <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_set_quality(System.Int32,System.Boolean)"/>.
            </remarks>
            <seealso href="../articles/KB/compression-parameter-selection.html">Compression parameter selection</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_set_colorspace(BitMiracle.LibJpeg.Classic.J_COLOR_SPACE)">
            <summary>
            Set the JPEG colorspace (property <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Jpeg_color_space"/>,
            and choose colorspace-dependent parameters appropriately.
            </summary>
            <param name="colorspace">The required colorspace.</param>
            <remarks>See <see href="../articles/KB/special-color-spaces.html">Special color spaces</see>, 
            below, before using this. A large number of parameters, including all per-component parameters, 
            are set by this routine; if you want to twiddle individual parameters you should call 
            <c>jpeg_set_colorspace</c> before rather than after.</remarks>
            <seealso href="../articles/KB/compression-parameter-selection.html">Compression parameter selection</seealso>
            <seealso href="../articles/KB/special-color-spaces.html">Special color spaces</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_default_colorspace">
            <summary>
            Select an appropriate JPEG colorspace based on <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.In_color_space"/>,
            and calls <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_set_colorspace(BitMiracle.LibJpeg.Classic.J_COLOR_SPACE)"/>
            </summary>
            <remarks>This is actually a subroutine of <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_set_defaults"/>. 
            It's broken out in case you want to change just the colorspace-dependent JPEG parameters.</remarks>
            <seealso href="../articles/KB/compression-parameter-selection.html">Compression parameter selection</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_set_quality(System.Int32,System.Boolean)">
            <summary>
            Constructs JPEG quantization tables appropriate for the indicated quality setting.
            </summary>
            <param name="quality">The quality value is expressed on the 0..100 scale recommended by IJG.</param>
            <param name="force_baseline">If <c>true</c>, then the quantization table entries are constrained 
            to the range 1..255 for full JPEG baseline compatibility. In the current implementation, 
            this only makes a difference for quality settings below 25, and it effectively prevents 
            very small/low quality files from being generated. The IJG decoder is capable of reading 
            the non-baseline files generated at low quality settings when <c>force_baseline</c> is <c>false</c>,
            but other decoders may not be.</param>
            <remarks>Note that the exact mapping from quality values to tables may change in future IJG releases 
            as more is learned about DCT quantization.</remarks>
            <seealso href="../articles/KB/compression-parameter-selection.html">Compression parameter selection</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_default_qtables(System.Boolean)">
            <summary>
            Set or change the 'quality' (quantization) setting, using default tables
            and straight percentage-scaling quality scales.
            This entry point allows different scalings for luminance and chrominance.
            </summary>
            <param name="force_baseline">if set to <c>true</c> then baseline version is forced.</param>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_set_linear_quality(System.Int32,System.Boolean)">
            <summary>
            Same as <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_set_quality(System.Int32,System.Boolean)"/> except that the generated tables are the 
            sample tables given in the JPEG specification section K.1, multiplied by 
            the specified scale factor.
            </summary>
            <param name="scale_factor">The scale_factor.</param>
            <param name="force_baseline">If <c>true</c>, then the quantization table entries are 
            constrained to the range 1..255 for full JPEG baseline compatibility. In the current 
            implementation, this only makes a difference for quality settings below 25, and it 
            effectively prevents very small/low quality files from being generated. The IJG decoder 
            is capable of reading the non-baseline files generated at low quality settings when 
            <c>force_baseline</c> is <c>false</c>, but other decoders may not be.</param>
            <remarks>Note that larger scale factors give lower quality. This entry point is 
            useful for conforming to the Adobe PostScript DCT conventions, but we do not 
            recommend linear scaling as a user-visible quality scale otherwise.
            </remarks>
            <seealso href="../articles/KB/compression-parameter-selection.html">Compression parameter selection</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_add_quant_table(System.Int32,System.Int32[],System.Int32,System.Boolean)">
            <summary>
            Allows an arbitrary quantization table to be created.
            </summary>
            <param name="which_tbl">Indicates which table slot to fill.</param>
            <param name="basic_table">An array of 64 unsigned integers given in normal array order.
            These values are multiplied by <c>scale_factor/100</c> and then clamped to the range 1..65535 
            (or to 1..255 if <c>force_baseline</c> is <c>true</c>).<br/>
            The basic table should be given in JPEG zigzag order.
            </param>
            <param name="scale_factor">Multiplier for values in <c>basic_table</c>.</param>
            <param name="force_baseline">Defines range of values in <c>basic_table</c>. 
            If <c>true</c> - 1..255, otherwise - 1..65535.</param>
            <seealso href="../articles/KB/compression-parameter-selection.html">Compression parameter selection</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_quality_scaling(System.Int32)">
            <summary>
            Converts a value on the IJG-recommended quality scale to a linear scaling percentage.
            </summary>
            <param name="quality">The IJG-recommended quality scale. Should be 0 (terrible) to 100 (very good).</param>
            <returns>The linear scaling percentage.</returns>
            <seealso href="../articles/KB/compression-parameter-selection.html">Compression parameter selection</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_simple_progression">
            <summary>
            Generates a default scan script for writing a progressive-JPEG file.
            </summary>
            <remarks>This is the recommended method of creating a progressive file, unless you want 
            to make a custom scan sequence. You must ensure that the JPEG color space is 
            set correctly before calling this routine.</remarks>
            <seealso href="../articles/KB/compression-parameter-selection.html">Compression parameter selection</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_start_compress(System.Boolean)">
            <summary>
            Starts JPEG compression.
            </summary>
            <param name="write_all_tables">Write or not write all quantization and Huffman tables.</param>
            <remarks>Before calling this, all parameters and a data destination must be set up.</remarks>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_suppress_tables(System.Boolean)"/>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_tables"/>
            <seealso href="../articles/KB/compression-details.html">Compression details</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_scanlines(System.Byte[][],System.Int32)">
            <summary>
            Write some scanlines of data to the JPEG compressor.
            </summary>
            <param name="scanlines">The array of scanlines.</param>
            <param name="num_lines">The number of scanlines for writing.</param>
            <returns>The return value will be the number of lines actually written.<br/>
            This should be less than the supplied <c>num_lines</c> only in case that 
            the data destination module has requested suspension of the compressor, 
            or if more than image_height scanlines are passed in.
            </returns>
            <remarks>We warn about excess calls to <c>jpeg_write_scanlines()</c> since this likely 
            signals an application programmer error. However, excess scanlines passed in the last 
            valid call are "silently" ignored, so that the application need not adjust <c>num_lines</c>
            for end-of-image when using a multiple-scanline buffer.</remarks>
            <seealso href="../articles/KB/compression-details.html">Compression details</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_raw_data(System.Byte[][][],System.Int32)">
            <summary>
            Alternate entry point to write raw data.
            </summary>
            <param name="data">The raw data.</param>
            <param name="num_lines">The number of scanlines for writing.</param>
            <returns>The number of lines actually written.</returns>
            <remarks>Processes exactly one iMCU row per call, unless suspended.
            Replaces <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_scanlines(System.Byte[][],System.Int32)"/> when writing raw downsampled data.</remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_coefficients(BitMiracle.LibJpeg.Classic.jvirt_array{BitMiracle.LibJpeg.Classic.JBLOCK}[])">
            <summary>
            Compression initialization for writing raw-coefficient data. Useful for lossless transcoding.
            </summary>
            <param name="coef_arrays">The virtual arrays need not be filled or even realized at the time 
            <c>jpeg_write_coefficients</c> is called; indeed, the virtual arrays typically will be realized 
            during this routine and filled afterwards.
            </param>
            <remarks>Before calling this, all parameters and a data destination must be set up.
            Call <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_finish_compress"/> to actually write the data.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.initialize">
            <summary>
            Initialization of a JPEG compression object
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jinit_compress_master">
            <summary>
            Master selection of compression modules.
            This is done once at the start of processing an image.  We determine
            which modules will be used and give them appropriate initialization calls.
            This routine is in charge of selecting the modules to be executed and
            making an initialization call to each one.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jinit_c_master_control(System.Boolean)">
            <summary>
            Initialize master compression control.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jinit_c_main_controller(System.Boolean)">
            <summary>
            Initialize main buffer controller.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.transencode_master_selection(BitMiracle.LibJpeg.Classic.jvirt_array{BitMiracle.LibJpeg.Classic.JBLOCK}[])">
            <summary>
            Master selection of compression modules for transcoding.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.initial_setup(System.Boolean)">
            <summary>
            Do computations that are needed before master selection phase
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.validate_script">
            <summary>
            Verify that the scan script in scan_info[] is valid; 
            also determine whether it uses progressive JPEG, and set progressive_mode.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.std_huff_tables">
            <summary>
            Set up the standard Huffman tables (cf. JPEG standard section K.3)
            
            IMPORTANT: these are only valid for 8-bit data precision!
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.add_huff_table(BitMiracle.LibJpeg.Classic.JHUFF_TBL@,System.Byte[],System.Byte[])">
            <summary>
            Define a Huffman table
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.fill_a_scan(System.Int32@,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Support routine: generate one scan for specified component
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.fill_dc_scans(System.Int32@,System.Int32,System.Int32,System.Int32)">
            <summary>
            Support routine: generate interleaved DC scan if possible, else N scans
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.fill_scans(System.Int32@,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Support routine: generate one scan for each component
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct">
            <summary>
            JPEG decompression routine.
            </summary>
            <seealso cref="T:BitMiracle.LibJpeg.Classic.jpeg_compress_struct"/>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_marker_parser_method">
            <summary>
            The delegate for application-supplied marker processing methods.
            </summary>
            <param name="cinfo">Decompressor.</param>
            <returns>Return <c>true</c> to indicate success. <c>false</c> should be returned only 
            if you are using a suspending data source and it tells you to suspend.
            </returns>
            <remarks>Although the marker code is not explicitly passed, the routine can find it 
            in the <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Unread_marker"/>. At the time of call, 
            the marker proper has been read from the data source module. The processor routine 
            is responsible for reading the marker length word and the remaining parameter bytes, if any.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct"/> class.
            </summary>
            <seealso cref="T:BitMiracle.LibJpeg.Classic.jpeg_compress_struct"/>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.#ctor(BitMiracle.LibJpeg.Classic.jpeg_error_mgr)">
            <summary>
            Initializes a new instance of the <see cref="T:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct"/> class.
            </summary>
            <param name="errorManager">The error manager.</param>
            <seealso cref="T:BitMiracle.LibJpeg.Classic.jpeg_compress_struct"/>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.IsDecompressor">
            <summary>
            Retrieves <c>true</c> because this is a decompressor.
            </summary>
            <value><c>true</c></value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Src">
            <summary>
            Gets or sets the source for decompression.
            </summary>
            <value>The source for decompression.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Image_width">
            <summary>
            Gets the width of image, set by <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_read_header(System.Boolean)"/>
            </summary>
            <value>The width of image.</value>
            <seealso href="../articles/KB/decompression-parameter-selection.html">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Image_height">
            <summary>
            Gets the height of image, set by <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_read_header(System.Boolean)"/>
            </summary>
            <value>The height of image.</value>
            <seealso href="../articles/KB/decompression-parameter-selection.html">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Num_components">
            <summary>
            Gets the number of color components in JPEG image.
            </summary>
            <value>The number of color components.</value>
            <seealso href="../articles/KB/decompression-parameter-selection.html">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Jpeg_color_space">
            <summary>
            Gets or sets the colorspace of JPEG image.
            </summary>
            <value>The colorspace of JPEG image.</value>
            <seealso href="../articles/KB/decompression-parameter-selection.html">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Marker_list">
            <summary>
            Gets the list of loaded special markers.
            </summary>
            <remarks>All the special markers in the file appear in this list, in order of 
            their occurrence in the file (but omitting any markers of types you didn't ask for)
            </remarks>
            <value>The list of loaded special markers.</value>
            <seealso href="../articles/KB/special-markers.html">Special markers</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Out_color_space">
            <summary>
            Gets or sets the output color space.
            </summary>
            <value>The output color space.</value>
            <seealso href="../articles/KB/decompression-parameter-selection.html">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Scale_num">
            <summary>
            Gets or sets the numerator of the fraction of image scaling.
            </summary>
            <value>Scale the image by the fraction Scale_num/<see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Scale_denom">Scale_denom</see>. 
            Default is 1/1, or no scaling. Currently, the only supported scaling ratios are 1/1, 1/2, 1/4, and 1/8.
            (The library design allows for arbitrary scaling ratios but this is not likely to be implemented any time soon.)
            </value>
            <remarks>Smaller scaling ratios permit significantly faster decoding since fewer pixels 
            need to be processed and a simpler <see cref="T:BitMiracle.LibJpeg.Classic.J_DCT_METHOD">DCT method</see> can be used.</remarks>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Scale_denom"/>
            <seealso href="../articles/KB/decompression-parameter-selection.html">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Scale_denom">
            <summary>
            Gets or sets the denominator of the fraction of image scaling.
            </summary>
            <value>Scale the image by the fraction <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Scale_num">Scale_num</see>/Scale_denom. 
            Default is 1/1, or no scaling. Currently, the only supported scaling ratios are 1/1, 1/2, 1/4, and 1/8.
            (The library design allows for arbitrary scaling ratios but this is not likely to be implemented any time soon.)
            </value>
            <remarks>Smaller scaling ratios permit significantly faster decoding since fewer pixels 
            need to be processed and a simpler <see cref="T:BitMiracle.LibJpeg.Classic.J_DCT_METHOD">DCT method</see> can be used.</remarks>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Scale_num"/>
            <seealso href="../articles/KB/decompression-parameter-selection.html">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Buffered_image">
            <summary>
            Gets or sets a value indicating whether to use buffered-image mode.
            </summary>
            <value><c>true</c> if buffered-image mode is turned on; otherwise, <c>false</c>.</value>
            <seealso href="../articles/KB/buffered-image-mode.html">Buffered-image mode</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Raw_data_out">
            <summary>
            Enable or disable raw data output.
            </summary>
            <value><c>true</c> if raw data output is enabled; otherwise, <c>false</c>.</value>
            <remarks>Default value: <c>false</c><br/>
            Set this to true before <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_start_decompress"/> 
            if you need to obtain raw data output.
            </remarks>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_read_raw_data(System.Byte[][][],System.Int32)"/>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Dct_method">
            <summary>
            Gets or sets the algorithm used for the DCT step.
            </summary>
            <value>The algorithm used for the DCT step.</value>
            <seealso href="../articles/KB/decompression-parameter-selection.html">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Do_fancy_upsampling">
            <summary>
            Enable or disable upsampling of chroma components.
            </summary>
            <value>If <c>true</c>, do careful upsampling of chroma components. 
            If <c>false</c>, a faster but sloppier method is used. 
            The visual impact of the sloppier method is often very small.
            </value>
            <remarks>Default value: <c>true</c></remarks>
            <seealso href="../articles/KB/decompression-parameter-selection.html">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Do_block_smoothing">
            <summary>
            Apply interblock smoothing in early stages of decoding progressive JPEG files.
            </summary>
            <value>If <c>true</c>, interblock smoothing is applied in early stages of decoding progressive JPEG files; 
            if <c>false</c>, not. Early progression stages look "fuzzy" with smoothing, "blocky" without.</value>
            <remarks>Default value: <c>true</c><br/>
            In any case, block smoothing ceases to be applied after the first few AC coefficients are 
            known to full accuracy, so it is relevant only when using 
            <see href="../articles/KB/buffered-image-mode.html">buffered-image mode</see> for progressive images.
            </remarks>
            <seealso href="../articles/KB/decompression-parameter-selection.html">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Quantize_colors">
            <summary>
            Colors quantization.
            </summary>
            <value>If set <c>true</c>, colormapped output will be delivered.<br/>
            Default value: <c>false</c>, meaning that full-color output will be delivered.
            </value>
            <seealso href="../articles/KB/decompression-parameter-selection.html">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Dither_mode">
            <summary>
            Selects color dithering method.
            </summary>
            <value>Default value: <see cref="F:BitMiracle.LibJpeg.Classic.J_DITHER_MODE.JDITHER_FS"/>.</value>
            <remarks>Ignored if <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Quantize_colors"/> is <c>false</c>.<br/>
            At present, ordered dither is implemented only in the single-pass, standard-colormap case. 
            If you ask for ordered dither when <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Two_pass_quantize"/> is <c>true</c>
            or when you supply an external color map, you'll get F-S dithering.
            </remarks>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Quantize_colors"/>
            <seealso href="../articles/KB/decompression-parameter-selection.html">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Two_pass_quantize">
            <summary>
            Gets or sets a value indicating whether to use two-pass color quantization.
            </summary>
            <value>If <c>true</c>, an extra pass over the image is made to select a custom color map for the image.
            This usually looks a lot better than the one-size-fits-all colormap that is used otherwise.
            Ignored when the application supplies its own color map.<br/>
            
            Default value: <c>true</c>
            </value>
            <remarks>Ignored if <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Quantize_colors"/> is <c>false</c>.<br/>
            </remarks>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Quantize_colors"/>
            <seealso href="../articles/KB/decompression-parameter-selection.html">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Desired_number_of_colors">
            <summary>
            Maximum number of colors to use in generating a library-supplied color map.
            </summary>
            <value>Default value: 256.</value>
            <remarks>Ignored if <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Quantize_colors"/> is <c>false</c>.<br/>
            The actual number of colors is returned in a <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Actual_number_of_colors"/>.
            </remarks>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Quantize_colors"/>
            <seealso href="../articles/KB/decompression-parameter-selection.html">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Enable_1pass_quant">
            <summary>
            Enable future use of 1-pass quantizer.
            </summary>
            <value>Default value: <c>false</c></value>
            <remarks>Significant only in buffered-image mode.</remarks>
            <seealso href="../articles/KB/buffered-image-mode.html">Buffered-image mode</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Enable_external_quant">
            <summary>
            Enable future use of external colormap.
            </summary>
            <value>Default value: <c>false</c></value>
            <remarks>Significant only in buffered-image mode.</remarks>
            <seealso href="../articles/KB/buffered-image-mode.html">Buffered-image mode</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Enable_2pass_quant">
            <summary>
            Enable future use of 2-pass quantizer.
            </summary>
            <value>Default value: <c>false</c></value>
            <remarks>Significant only in buffered-image mode.</remarks>
            <seealso href="../articles/KB/buffered-image-mode.html">Buffered-image mode</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Output_width">
            <summary>
            Gets the actual width of output image.
            </summary>
            <value>The width of output image.</value>
            <remarks>Computed by <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_start_decompress"/>.
            You can also use <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_calc_output_dimensions"/> to determine this value
            in advance of calling <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_start_decompress"/>.</remarks>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Output_height"/>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Output_height">
            <summary>
            Gets the actual height of output image.
            </summary>
            <value>The height of output image.</value>
            <remarks>Computed by <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_start_decompress"/>.
            You can also use <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_calc_output_dimensions"/> to determine this value
            in advance of calling <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_start_decompress"/>.</remarks>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Output_width"/>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Out_color_components">
            <summary>
            Gets the number of color components in <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Out_color_space"/>.
            </summary>
            <remarks>Computed by <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_start_decompress"/>.
            You can also use <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_calc_output_dimensions"/> to determine this value
            in advance of calling <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_start_decompress"/>.</remarks>
            <value>The number of color components.</value>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Out_color_space"/>
            <seealso href="../articles/KB/decompression-parameter-selection.html">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Output_components">
            <summary>
            Gets the number of color components returned.
            </summary>
            <remarks>Computed by <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_start_decompress"/>.
            You can also use <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_calc_output_dimensions"/> to determine this value
            in advance of calling <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_start_decompress"/>.</remarks>
            <value>When <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Quantize_colors">quantizing colors</see>, 
            <c>Output_components</c> is 1, indicating a single color map index per pixel. 
            Otherwise it equals to <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Out_color_components"/>.
            </value>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Out_color_space"/>
            <seealso href="../articles/KB/decompression-parameter-selection.html">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Rec_outbuf_height">
            <summary>
            Gets the recommended height of scanline buffer.
            </summary>
            <value>In high-quality modes, <c>Rec_outbuf_height</c> is always 1, but some faster, 
            lower-quality modes set it to larger values (typically 2 to 4).</value>
            <remarks>Computed by <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_start_decompress"/>.
            You can also use <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_calc_output_dimensions"/> to determine this value
            in advance of calling <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_start_decompress"/>.<br/>
            
            <c>Rec_outbuf_height</c> is the recommended minimum height (in scanlines) 
            of the buffer passed to <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_read_scanlines(System.Byte[][],System.Int32)"/>.
            If the buffer is smaller, the library will still work, but time will be wasted due 
            to unnecessary data copying. If you are going to ask for a high-speed processing mode, 
            you may as well go to the trouble of honoring <c>Rec_outbuf_height</c> so as to avoid data copying.
            (An output buffer larger than <c>Rec_outbuf_height</c> lines is OK, but won't provide 
            any material speed improvement over that height.)
            </remarks>
            <seealso href="../articles/KB/decompression-parameter-selection.html">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Actual_number_of_colors">
            <summary>
            The number of colors in the color map.
            </summary>
            <value>The number of colors in the color map.</value>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Colormap"/>
            <seealso href="../articles/KB/decompression-parameter-selection.html">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Colormap">
            <summary>
            The color map, represented as a 2-D pixel array of <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Out_color_components"/> rows 
            and <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Actual_number_of_colors"/> columns.
            </summary>
            <value>Colormap is set to <c>null</c> by <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_read_header(System.Boolean)"/>.
            The application can supply a color map by setting <c>Colormap</c> non-null and setting 
            <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Actual_number_of_colors"/> to the map size.
            </value>
            <remarks>Ignored if not quantizing.<br/>
            Implementation restriction: at present, an externally supplied <c>Colormap</c>
            is only accepted for 3-component output color spaces.
            </remarks>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Actual_number_of_colors"/>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Quantize_colors"/>
            <seealso href="../articles/KB/decompression-parameter-selection.html">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Output_scanline">
            <summary>
            Gets the number of scanlines returned so far.
            </summary>
            <value>The output_scanline.</value>
            <remarks>Usually you can just use this variable as the loop counter, 
            so that the loop test looks like 
            <c>while (cinfo.Output_scanline &lt; cinfo.Output_height)</c></remarks>
            <seealso href="../articles/KB/decompression-details.html">Decompression details</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Input_scan_number">
            <summary>
            Gets the number of SOS markers seen so far.
            </summary>
            <value>The number of SOS markers seen so far.</value>
            <remarks>Indicates the progress of the decompressor input side.</remarks>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Input_iMCU_row">
            <summary>
            Gets the number of iMCU rows completed.
            </summary>
            <value>The number of iMCU rows completed.</value>
            <remarks>Indicates the progress of the decompressor input side.</remarks>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Output_scan_number">
            <summary>
            Gets the nominal scan number being displayed.
            </summary>
            <value>The nominal scan number being displayed.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Output_iMCU_row">
            <summary>
            Gets the number of iMCU rows read.
            </summary>
            <value>The number of iMCU rows read.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Coef_bits">
            <summary>
            Gets the current progression status..
            </summary>
            <value><c>Coef_bits[c][i]</c> indicates the precision with 
            which component c's DCT coefficient i (in zigzag order) is known. 
            It is <c>-1</c> when no data has yet been received, otherwise 
            it is the point transform (shift) value for the most recent scan of the coefficient 
            (thus, 0 at completion of the progression). This is null when reading a non-progressive file.
            </value>
            <seealso href="../articles/KB/progressive-jpeg.html">Progressive JPEG support</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Density_unit">
            <summary>
            Gets the resolution information from JFIF marker.
            </summary>
            <value>The information from JFIF marker.</value>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.X_density"/>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Y_density"/>
            <seealso href="../articles/KB/decompression-parameter-selection.html">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.X_density">
            <summary>
            Gets the horizontal component of pixel ratio.
            </summary>
            <value>The horizontal component of pixel ratio.</value>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Y_density"/>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Density_unit"/>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Y_density">
            <summary>
            Gets the vertical component of pixel ratio.
            </summary>
            <value>The vertical component of pixel ratio.</value>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.X_density"/>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Density_unit"/>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Data_precision">
            <summary>
            Gets the data precision.
            </summary>
            <value>The data precision.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Max_v_samp_factor">
            <summary>
            Gets the largest vertical sample factor.
            </summary>
            <value>The largest vertical sample factor.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Unread_marker">
            <summary>
            Gets the last read and unprocessed JPEG marker.
            </summary>
            <value>It is either zero or the code of a JPEG marker that has been
            read from the data source, but has not yet been processed.
            </value>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_set_marker_processor(System.Int32,BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_marker_parser_method)"/>
            <seealso href="../articles/KB/special-markers.html">Special markers</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Comp_info">
            <summary>
            Comp_info[i] describes component that appears i'th in SOF
            </summary>
            <value>The components in SOF.</value>
            <seealso cref="T:BitMiracle.LibJpeg.Classic.jpeg_component_info"/>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_stdio_src(System.IO.Stream)">
            <summary>
            Sets input stream.
            </summary>
            <param name="infile">The input stream.</param>
            <remarks>
            The caller must have already opened the stream, and is responsible
            for closing it after finishing decompression.
            </remarks>
            <seealso href="../articles/KB/decompression-details.html">Decompression details</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_read_header(System.Boolean)">
            <summary>
            Decompression startup: this will read the source datastream header markers, up to the beginning of the compressed data proper.
            </summary>
            <param name="require_image">Read a description of <b>Return Value</b>.</param>
            <returns>
            If you pass <c>require_image=true</c> (normal case), you need not check for a
            <see cref="F:BitMiracle.LibJpeg.Classic.ReadResult.JPEG_HEADER_TABLES_ONLY"/> return code; an abbreviated file will cause
            an error exit. <see cref="F:BitMiracle.LibJpeg.Classic.ReadResult.JPEG_SUSPENDED"/> is only possible if you use a data source
            module that can give a suspension return.<br/><br/>
            
            This method will read as far as the first SOS marker (ie, actual start of compressed data),
            and will save all tables and parameters in the JPEG object. It will also initialize the
            decompression parameters to default values, and finally return <see cref="F:BitMiracle.LibJpeg.Classic.ReadResult.JPEG_HEADER_OK"/>.
            On return, the application may adjust the decompression parameters and then call
            <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_start_decompress"/>. (Or, if the application only wanted to
            determine the image parameters, the data need not be decompressed. In that case, call
            <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.jpeg_abort"/> to release any temporary space.)<br/><br/>
            
            If an abbreviated (tables only) datastream is presented, the routine will return
            <see cref="F:BitMiracle.LibJpeg.Classic.ReadResult.JPEG_HEADER_TABLES_ONLY"/> upon reaching EOI. The application may then re-use
            the JPEG object to read the abbreviated image datastream(s). It is unnecessary (but OK) to call
            <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.jpeg_abort">jpeg_abort</see> in this case.
            The <see cref="F:BitMiracle.LibJpeg.Classic.ReadResult.JPEG_SUSPENDED"/> return code only occurs if the data source module
            requests suspension of the decompressor. In this case the application should load more source
            data and then re-call <c>jpeg_read_header</c> to resume processing.<br/><br/>
            
            If a non-suspending data source is used and <c>require_image</c> is <c>true</c>,
            then the return code need not be inspected since only <see cref="F:BitMiracle.LibJpeg.Classic.ReadResult.JPEG_HEADER_OK"/> is possible.
            </returns>
            <remarks>Need only initialize JPEG object and supply a data source before calling.<br/>
            On return, the image dimensions and other info have been stored in the JPEG object.
            The application may wish to consult this information before selecting decompression parameters.<br/>
            This routine is now just a front end to <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_consume_input"/>, with some extra error checking.
            </remarks>
            <seealso href="../articles/KB/decompression-details.html">Decompression details</seealso>
            <seealso href="../articles/KB/decompression-parameter-selection.html">Decompression parameter selection</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_start_decompress">
            <summary>
            Decompression initialization.
            </summary>
            <returns>Returns <c>false</c> if suspended. The return value need be inspected 
            only if a suspending data source is used.
            </returns>
            <remarks><see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_read_header(System.Boolean)">jpeg_read_header</see> must be completed before calling this.<br/>
            
            If a multipass operating mode was selected, this will do all but the last pass, and thus may take a great deal of time.
            </remarks>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_finish_decompress"/>
            <seealso href="../articles/KB/decompression-details.html">Decompression details</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_read_scanlines(System.Byte[][],System.Int32)">
            <summary>
            Read some scanlines of data from the JPEG decompressor.
            </summary>
            <param name="scanlines">Buffer for filling.</param>
            <param name="max_lines">Required number of lines.</param>
            <returns>The return value will be the number of lines actually read. 
            This may be less than the number requested in several cases, including 
            bottom of image, data source suspension, and operating modes that emit multiple scanlines at a time.
            </returns>
            <remarks>We warn about excess calls to <c>jpeg_read_scanlines</c> since this likely signals an 
            application programmer error. However, an oversize buffer <c>(max_lines > scanlines remaining)</c> 
            is not an error.
            </remarks>
            <seealso href="../articles/KB/decompression-details.html">Decompression details</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_finish_decompress">
            <summary>
            Finish JPEG decompression.
            </summary>
            <returns>Returns <c>false</c> if suspended. The return value need be inspected 
            only if a suspending data source is used.
            </returns>
            <remarks>This will normally just verify the file trailer and release temp storage.</remarks>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_start_decompress"/>
            <seealso href="../articles/KB/decompression-details.html">Decompression details</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_read_raw_data(System.Byte[][][],System.Int32)">
            <summary>
            Alternate entry point to read raw data.
            </summary>
            <param name="data">The raw data.</param>
            <param name="max_lines">The number of scanlines for reading.</param>
            <returns>The number of lines actually read.</returns>
            <remarks>Replaces <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_read_scanlines(System.Byte[][],System.Int32)">jpeg_read_scanlines</see> 
            when reading raw downsampled data. Processes exactly one iMCU row per call, unless suspended.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_has_multiple_scans">
            <summary>
            Is there more than one scan?
            </summary>
            <returns><c>true</c> if image has more than one scan; otherwise, <c>false</c></returns>
            <remarks>If you are concerned about maximum performance on baseline JPEG files,
            you should use <see href="../articles/KB/buffered-image-mode.html">buffered-image mode</see> only
            when the incoming file actually has multiple scans. This can be tested by calling this method.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_start_output(System.Int32)">
            <summary>
            Initialize for an output pass in <see href="../articles/KB/buffered-image-mode.html">buffered-image mode</see>.
            </summary>
            <param name="scan_number">Indicates which scan of the input file is to be displayed; 
            the scans are numbered starting at 1 for this purpose.</param>
            <returns><c>true</c> if done; <c>false</c> if suspended</returns>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_finish_output"/>
            <seealso href="../articles/KB/buffered-image-mode.html">Buffered-image mode</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_finish_output">
            <summary>
            Finish up after an output pass in <see href="../articles/KB/buffered-image-mode.html">buffered-image mode</see>.
            </summary>
            <returns>Returns <c>false</c> if suspended. The return value need be inspected only if a suspending data source is used.</returns>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_start_output(System.Int32)"/>
            <seealso href="../articles/KB/buffered-image-mode.html">Buffered-image mode</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_input_complete">
            <summary>
            Indicates if we have finished reading the input file.
            </summary>
            <returns><c>true</c> if we have finished reading the input file.</returns>
            <seealso href="../articles/KB/buffered-image-mode.html">Buffered-image mode</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_consume_input">
            <summary>
            Consume data in advance of what the decompressor requires.
            </summary>
            <returns>The result of data consumption.</returns>
            <remarks>This routine can be called at any time after initializing the JPEG object.
            It reads some additional data and returns when one of the indicated significant events
            occurs. If called after the EOI marker is reached, it will immediately return
            <see cref="F:BitMiracle.LibJpeg.Classic.ReadResult.JPEG_REACHED_EOI"/> without attempting to read more data.</remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_calc_output_dimensions">
            <summary>
            Pre-calculate output image dimensions and related values for current decompression parameters.
            </summary>
            <remarks>This is allowed for possible use by application. Hence it mustn't do anything 
            that can't be done twice. Also note that it may be called before the master module is initialized!
            </remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_read_coefficients">
            <summary>
            Read or write the raw DCT coefficient arrays from a JPEG file (useful for lossless transcoding).
            </summary>
            <returns>Returns <c>null</c> if suspended. This case need be checked only 
            if a suspending data source is used.
            </returns>
            <remarks>
            <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_read_header(System.Boolean)">jpeg_read_header</see> must be completed before calling this.<br/>
            
            The entire image is read into a set of virtual coefficient-block arrays, one per component.
            The return value is an array of virtual-array descriptors.<br/>
            
            An alternative usage is to simply obtain access to the coefficient arrays during a 
            <see href="../articles/KB/buffered-image-mode.html">buffered-image mode</see> decompression operation. This is allowed after any 
            <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_finish_output">jpeg_finish_output</see> call. The arrays can be accessed 
            until <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_finish_decompress">jpeg_finish_decompress</see> is called. 
            Note that any call to the library may reposition the arrays, 
            so don't rely on <see cref="M:BitMiracle.LibJpeg.Classic.jvirt_array`1.Access(System.Int32,System.Int32)"/> results to stay valid across library calls.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_copy_critical_parameters(BitMiracle.LibJpeg.Classic.jpeg_compress_struct)">
            <summary>
            Initializes the compression object with default parameters, then copy from the source object 
            all parameters needed for lossless transcoding.
            </summary>
            <param name="dstinfo">Target JPEG compression object.</param>
            <remarks>Parameters that can be varied without loss (such as scan script and 
            Huffman optimization) are left in their default states.</remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_abort_decompress">
            <summary>
            Aborts processing of a JPEG decompression operation.
            </summary>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.jpeg_abort"/>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_set_marker_processor(System.Int32,BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_marker_parser_method)">
            <summary>
            Sets processor for special marker.
            </summary>
            <param name="marker_code">The marker code.</param>
            <param name="routine">The processor.</param>
            <remarks>Allows you to supply your own routine to process 
            COM and/or APPn markers on-the-fly as they are read.
            </remarks>
            <seealso href="../articles/KB/special-markers.html">Special markers</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_save_markers(System.Int32,System.Int32)">
            <summary>
            Control saving of COM and APPn markers into <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Marker_list">Marker_list</see>.
            </summary>
            <param name="marker_code">The marker type to save (see JPEG_MARKER enumeration).<br/>
            To arrange to save all the special marker types, you need to call this 
            routine 17 times, for COM and APP0-APP15 markers.</param>
            <param name="length_limit">If the incoming marker is longer than <c>length_limit</c> data bytes, 
            only <c>length_limit</c> bytes will be saved; this parameter allows you to avoid chewing up memory 
            when you only need to see the first few bytes of a potentially large marker. If you want to save 
            all the data, set <c>length_limit</c> to 0xFFFF; that is enough since marker lengths are only 16 bits. 
            As a special case, setting <c>length_limit</c> to 0 prevents that marker type from being saved at all. 
            (That is the default behavior, in fact.)
            </param>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Marker_list"/>
            <seealso href="../articles/KB/special-markers.html">Special markers</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.use_merged_upsample">
            <summary>
            Determine whether merged upsample/color conversion should be used.
            CRUCIAL: this must match the actual capabilities of merged upsampler!
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.initialize">
            <summary>
            Initialization of JPEG compression objects.
            The error manager must already be set up (in case memory manager fails).
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.transdecode_master_selection">
            <summary>
            Master selection of decompression modules for transcoding (that is, reading 
            raw DCT coefficient arrays from an input JPEG file.)
            This substitutes for initialization of the full decompressor.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.output_pass_setup">
            <summary>
            Set up for an output pass, and perform any dummy pass(es) needed.
            Common subroutine for jpeg_start_decompress and jpeg_start_output.
            Entry: global_state = DSTATE_PRESCAN only if previously suspended.
            Exit: If done, returns true and sets global_state for proper output mode.
                  If suspended, returns false and sets global_state = DSTATE_PRESCAN.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.default_decompress_parms">
            <summary>
            Set default decompression parameters.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.jpeg_destination_mgr">
            <summary>
            Data destination object for compression.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_destination_mgr.init_destination">
            <summary>
            Initializes this instance.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_destination_mgr.empty_output_buffer">
            <summary>
            Empties output buffer.
            </summary>
            <returns><c>true</c> if operation succeed; otherwise, <c>false</c></returns>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_destination_mgr.term_destination">
            <summary>
            Term_destinations this instance.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_destination_mgr.emit_byte(System.Int32)">
            <summary>
            Emits a byte.
            </summary>
            <param name="val">The byte value.</param>
            <returns><c>true</c> if operation succeed; otherwise, <c>false</c></returns>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_destination_mgr.initInternalBuffer(System.Byte[],System.Int32)">
            <summary>
            Initializes the internal buffer.
            </summary>
            <param name="buffer">The buffer.</param>
            <param name="offset">The offset.</param>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_destination_mgr.freeInBuffer">
            <summary>
            Gets the number of free bytes in buffer.
            </summary>
            <value>The number of free bytes in buffer.</value>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.jpeg_error_mgr">
            <summary>
            Contains simple error-reporting and trace-message routines.
            </summary>
            <remarks>This class is used by both the compression and decompression code.</remarks>
            <seealso href="41dc1a3b-0dea-4594-87d2-c213ab1049e1.htm" target="_self">Error handling</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:BitMiracle.LibJpeg.Classic.jpeg_error_mgr"/> class.
            </summary>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.Trace_level">
            <summary>
            Gets or sets the maximum message level that will be displayed.
            </summary>
            <value>Values are:
            -1: recoverable corrupt-data warning, may want to abort.<br/>
            0: important advisory messages (always display to user).<br/>
            1: first level of tracing detail.<br/>
            2, 3, ...: successively more detailed tracing messages.
            </value>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.emit_message(System.Int32)"/>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.Num_warnings">
            <summary>
            Gets the number of corrupt-data warnings.
            </summary>
            <value>The num_warnings.</value>
            <remarks>For recoverable corrupt-data errors, we emit a warning message, but keep going 
            unless <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.emit_message(System.Int32)">emit_message</see> chooses to abort. 
            <c>emit_message</c> should count warnings in <c>Num_warnings</c>. The surrounding application 
            can check for bad data by seeing if <c>Num_warnings</c> is nonzero at the end of processing.</remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.error_exit">
            <summary>
            Receives control for a fatal error.
            </summary>
            <remarks>This method calls <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.output_message">output_message</see> 
            and then throws an exception.</remarks>
            <seealso href="41dc1a3b-0dea-4594-87d2-c213ab1049e1.htm" target="_self">Error handling</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.emit_message(System.Int32)">
            <summary>
            Conditionally emit a trace or warning message.
            </summary>
            <param name="msg_level">The message severity level.<br/>
            Values are:<br/>
            -1: recoverable corrupt-data warning, may want to abort.<br/>
            0: important advisory messages (always display to user).<br/>
            1: first level of tracing detail.<br/>
            2, 3, ...: successively more detailed tracing messages.
            </param>
            <remarks>The main reason for overriding this method would be to abort on warnings.
            This method calls <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.output_message">output_message</see> for message showing.<br/>
            
            An application might override this method if it wanted to abort on 
            warnings or change the policy about which messages to display.
            </remarks>
            <seealso href="41dc1a3b-0dea-4594-87d2-c213ab1049e1.htm" target="_self">Error handling</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.output_message">
            <summary>
            Actual output of any JPEG message.
            </summary>
            <remarks>Override this to send messages somewhere other than Console. 
            Note that this method does not know how to generate a message, only where to send it.
            For extending a generation of messages see <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.format_message">format_message</see>.
            </remarks>
            <seealso href="41dc1a3b-0dea-4594-87d2-c213ab1049e1.htm" target="_self">Error handling</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.format_message">
            <summary>
            Constructs a readable error message string.
            </summary>
            <remarks>This method is called by <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.output_message">output_message</see>.
            Few applications should need to override this method. One possible reason for doing so is to 
            implement dynamic switching of error message language.</remarks>
            <returns>The formatted message</returns>
            <seealso href="41dc1a3b-0dea-4594-87d2-c213ab1049e1.htm" target="_self">Error handling</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.reset_error_mgr">
            <summary>
            Resets error manager to initial state.
            </summary>
            <remarks>This is called during compression startup to reset trace/error
            processing to default state. An application might possibly want to
            override this method if it has additional error processing state.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.GetMessageText(System.Int32)">
            <summary>
            Gets the actual message texts.
            </summary>
            <param name="code">The message code. See <see cref="T:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE"/> for details.</param>
            <returns>The message text associated with <c>code</c>.</returns>
            <remarks>It may be useful for an application to add its own message texts that are handled 
            by the same mechanism. You can override <c>GetMessageText</c> for this purpose. If you number 
            the addon messages beginning at 1000 or so, you won't have to worry about conflicts 
            with the library's built-in messages.
            </remarks>
            <seealso cref="T:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE"/>
            <seealso href="41dc1a3b-0dea-4594-87d2-c213ab1049e1.htm" target="_self">Error handling</seealso>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.JPEG_MARKER">
            <summary>
            JPEG marker codes.
            </summary>
            <seealso href="81c88818-a5d7-4550-9ce5-024a768f7b1e.htm" target="_self">Special markers</seealso>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.SOF0">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.SOF1">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.SOF2">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.SOF3">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.SOF5">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.SOF6">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.SOF7">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.JPG">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.SOF9">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.SOF10">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.SOF11">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.SOF13">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.SOF14">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.SOF15">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.DHT">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.DAC">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.RST0">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.RST1">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.RST2">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.RST3">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.RST4">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.RST5">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.RST6">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.RST7">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.SOI">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.EOI">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.SOS">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.DQT">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.DNL">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.DRI">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.DHP">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.EXP">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.APP0">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.APP1">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.APP2">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.APP3">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.APP4">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.APP5">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.APP6">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.APP7">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.APP8">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.APP9">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.APP10">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.APP11">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.APP12">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.APP13">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.APP14">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.APP15">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.JPG0">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.JPG8">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.JPG13">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.COM">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.TEM">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.ERROR">
            <summary>
            
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.jpeg_marker_struct">
            <summary>
            Representation of special JPEG marker.
            </summary>
            <remarks>You can't create instance of this class manually.
            Concrete objects are instantiated by library and you can get them
            through <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Marker_list">Marker_list</see> property.
            </remarks>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Marker_list"/>
            <seealso href="81c88818-a5d7-4550-9ce5-024a768f7b1e.htm" target="_self">Special markers</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_marker_struct.Marker">
            <summary>
            Gets the special marker.
            </summary>
            <value>The marker value.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_marker_struct.OriginalLength">
            <summary>
            Gets the full length of original data associated with the marker.
            </summary>
            <value>The length of original data associated with the marker.</value>
            <remarks>This length excludes the marker length word, whereas the stored representation 
            within the JPEG file includes it. (Hence the maximum data length is really only 65533.)
            </remarks>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_marker_struct.Data">
            <summary>
            Gets the data associated with the marker.
            </summary>
            <value>The data associated with the marker.</value>
            <remarks>The length of this array doesn't exceed <c>length_limit</c> for the particular marker type.
            Note that this length excludes the marker length word, whereas the stored representation 
            within the JPEG file includes it. (Hence the maximum data length is really only 65533.)
            </remarks>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.jpeg_progress_mgr">
            <summary>
            The progress monitor object.
            </summary>
            <seealso href="febdc6af-ca72-4f3b-8cfe-3473ce6a7c7f.htm" target="_self">Progress monitoring</seealso>
        </member>
        <member name="E:BitMiracle.LibJpeg.Classic.jpeg_progress_mgr.OnProgress">
            <summary>
            Occurs when progress is changed.
            </summary>
            <seealso href="febdc6af-ca72-4f3b-8cfe-3473ce6a7c7f.htm" target="_self">Progress monitoring</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_progress_mgr.Pass_counter">
            <summary>
            Gets or sets the number of work units completed in this pass.
            </summary>
            <value>The number of work units completed in this pass.</value>
            <seealso href="febdc6af-ca72-4f3b-8cfe-3473ce6a7c7f.htm" target="_self">Progress monitoring</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_progress_mgr.Pass_limit">
            <summary>
            Gets or sets the total number of work units in this pass.
            </summary>
            <value>The total number of work units in this pass.</value>
            <seealso href="febdc6af-ca72-4f3b-8cfe-3473ce6a7c7f.htm" target="_self">Progress monitoring</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_progress_mgr.Completed_passes">
            <summary>
            Gets or sets the number of passes completed so far.
            </summary>
            <value>The number of passes completed so far.</value>
            <seealso href="febdc6af-ca72-4f3b-8cfe-3473ce6a7c7f.htm" target="_self">Progress monitoring</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_progress_mgr.Total_passes">
            <summary>
            Gets or sets the total number of passes expected.
            </summary>
            <value>The total number of passes expected.</value>
            <seealso href="febdc6af-ca72-4f3b-8cfe-3473ce6a7c7f.htm" target="_self">Progress monitoring</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_progress_mgr.Updated">
            <summary>
            Indicates that progress was changed.
            </summary>
            <remarks>Call this method if you change some progress parameters manually.
            This method ensures happening of the <see cref="E:BitMiracle.LibJpeg.Classic.jpeg_progress_mgr.OnProgress">OnProgress</see> event.</remarks>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.jpeg_source_mgr">
            <summary>
            Data source object for decompression.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_source_mgr.init_source">
            <summary>
            Initializes this instance.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_source_mgr.fill_input_buffer">
            <summary>
            Fills input buffer
            </summary>
            <returns><c>true</c> if operation succeed; otherwise, <c>false</c></returns>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_source_mgr.initInternalBuffer(System.Byte[],System.Int32)">
            <summary>
            Initializes the internal buffer.
            </summary>
            <param name="buffer">The buffer.</param>
            <param name="size">The size.</param>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_source_mgr.skip_input_data(System.Int32)">
            <summary>
            Skip data - used to skip over a potentially large amount of
            uninteresting data (such as an APPn marker).
            </summary>
            <param name="num_bytes">The number of bytes to skip.</param>
            <remarks>Writers of suspendable-input applications must note that skip_input_data
            is not granted the right to give a suspension return.  If the skip extends
            beyond the data currently in the buffer, the buffer can be marked empty so
            that the next read will cause a fill_input_buffer call that can suspend.
            Arranging for additional bytes to be discarded before reloading the input
            buffer is the application writer's problem.</remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_source_mgr.resync_to_restart(BitMiracle.LibJpeg.Classic.jpeg_decompress_struct,System.Int32)">
            <summary>
            This is the default resync_to_restart method for data source 
            managers to use if they don't have any better approach.
            </summary>
            <param name="cinfo">An instance of <see cref="T:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct"/></param>
            <param name="desired">The desired</param>
            <returns><c>false</c> if suspension is required.</returns>
            <remarks>That method assumes that no backtracking is possible. 
            Some data source managers may be able to back up, or may have 
            additional knowledge about the data which permits a more 
            intelligent recovery strategy; such managers would
            presumably supply their own resync method.<br/><br/>
            
            read_restart_marker calls resync_to_restart if it finds a marker other than
            the restart marker it was expecting.  (This code is *not* used unless
            a nonzero restart interval has been declared.)  cinfo.unread_marker is
            the marker code actually found (might be anything, except 0 or FF).
            The desired restart marker number (0..7) is passed as a parameter.<br/><br/>
            
            This routine is supposed to apply whatever error recovery strategy seems
            appropriate in order to position the input stream to the next data segment.
            Note that cinfo.unread_marker is treated as a marker appearing before
            the current data-source input point; usually it should be reset to zero
            before returning.<br/><br/>
            
            This implementation is substantially constrained by wanting to treat the
            input as a data stream; this means we can't back up.  Therefore, we have
            only the following actions to work with:<br/>
            1. Simply discard the marker and let the entropy decoder resume at next
            byte of file.<br/>
            2. Read forward until we find another marker, discarding intervening
            data.  (In theory we could look ahead within the current bufferload,
            without having to discard data if we don't find the desired marker.
            This idea is not implemented here, in part because it makes behavior
            dependent on buffer size and chance buffer-boundary positions.)<br/>
            3. Leave the marker unread (by failing to zero cinfo.unread_marker).
            This will cause the entropy decoder to process an empty data segment,
            inserting dummy zeroes, and then we will reprocess the marker.<br/>
            
            #2 is appropriate if we think the desired marker lies ahead, while #3 is
            appropriate if the found marker is a future restart marker (indicating
            that we have missed the desired restart marker, probably because it got
            corrupted).<br/>
            We apply #2 or #3 if the found marker is a restart marker no more than
            two counts behind or ahead of the expected one.  We also apply #2 if the
            found marker is not a legal JPEG marker code (it's certainly bogus data).
            If the found marker is a restart marker more than 2 counts away, we do #1
            (too much risk that the marker is erroneous; with luck we will be able to
            resync at some future point).<br/>
            For any valid non-restart JPEG marker, we apply #3.  This keeps us from
            overrunning the end of a scan.  An implementation limited to single-scan
            files might find it better to apply #2 for markers other than EOI, since
            any other marker would have to be bogus data in that case.</remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_source_mgr.term_source">
            <summary>
            Terminate source - called by jpeg_finish_decompress
            after all data has been read.  Often a no-op.
            </summary>
            <remarks>NB: <b>not</b> called by jpeg_abort or jpeg_destroy; surrounding
            application must deal with any cleanup that should happen even
            for error exit.</remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_source_mgr.GetTwoBytes(System.Int32@)">
            <summary>
            Reads two bytes interpreted as an unsigned 16-bit integer.
            </summary>
            <param name="V">The result.</param>
            <returns><c>true</c> if operation succeed; otherwise, <c>false</c></returns>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_source_mgr.GetByte(System.Int32@)">
            <summary>
            Read a byte into variable V.
            If must suspend, take the specified action (typically "return false").
            </summary>
            <param name="V">The result.</param>
            <returns><c>true</c> if operation succeed; otherwise, <c>false</c></returns>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_source_mgr.GetBytes(System.Byte[],System.Int32)">
            <summary>
            Gets the bytes.
            </summary>
            <param name="dest">The destination.</param>
            <param name="amount">The amount.</param>
            <returns>The number of available bytes.</returns>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_source_mgr.MakeByteAvailable">
            <summary>
            Functions for fetching data from the data source module.
            </summary>
            <returns><c>true</c> if operation succeed; otherwise, <c>false</c></returns>
            <remarks>At all times, cinfo.src.next_input_byte and .bytes_in_buffer reflect
            the current restart point; we update them only when we have reached a
            suitable place to restart if a suspension occurs.</remarks>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.JQUANT_TBL">
            <summary>
            DCT coefficient quantization tables.
            </summary>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.JQUANT_TBL.Sent_table">
            <summary>
            Gets or sets a value indicating whether the table has been output to file.
            </summary>
            <value>It's initialized <c>false</c> when the table is created, and set 
            <c>true</c> when it's been output to the file. You could suppress output of a table by setting this to <c>true</c>.
            </value>
            <remarks>This property is used only during compression.</remarks>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_suppress_tables(System.Boolean)"/>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.jvirt_array`1">
            <summary>
            JPEG virtual array.
            </summary>
            <typeparam name="T">The type of array's elements.</typeparam>
            <remarks>You can't create virtual array manually. For creation use methods
            <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.CreateSamplesArray(System.Int32,System.Int32)"/> and
            <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.CreateBlocksArray(System.Int32,System.Int32)"/>.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jvirt_array`1.#ctor(System.Int32,System.Int32,BitMiracle.LibJpeg.Classic.jvirt_array{`0}.Allocator)">
            <summary>
            Request a virtual 2-D array
            </summary>
            <param name="width">Width of array</param>
            <param name="height">Total virtual array height</param>
            <param name="allocator">The allocator.</param>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jvirt_array`1.ErrorProcessor">
            <summary>
            Gets or sets the error processor.
            </summary>
            <value>The error processor.<br/>
            Default value: <c>null</c>
            </value>
            <remarks>Uses only for calling 
            <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.ERREXIT(BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE)">jpeg_common_struct.ERREXIT</see>
            on error.</remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jvirt_array`1.Access(System.Int32,System.Int32)">
            <summary>
            Access the part of a virtual array.
            </summary>
            <param name="startRow">The first row in required block.</param>
            <param name="numberOfRows">The number of required rows.</param>
            <returns>The required part of virtual array.</returns>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.J_COLOR_SPACE">
            <summary>
            Known color spaces.
            </summary>
            <seealso href="c90654b9-f3f4-4319-80d1-979c73d84e76.htm" target="_self">Special color spaces</seealso>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_COLOR_SPACE.JCS_UNKNOWN">
            <summary>
            Unspecified color space.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_COLOR_SPACE.JCS_GRAYSCALE">
            <summary>
            Monochrome
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_COLOR_SPACE.JCS_RGB">
            <summary>
            Red/Green/Blue, standard RGB (sRGB)
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_COLOR_SPACE.JCS_YCbCr">
            <summary>
            Y/Cb/Cr (also known as YUV), standard YCC
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_COLOR_SPACE.JCS_CMYK">
            <summary>
            C/M/Y/K
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_COLOR_SPACE.JCS_YCCK">
            <summary>
             Y/Cb/Cr/K
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_COLOR_SPACE.JCS_BG_RGB">
            <summary>
            big gamut red/green/blue, bg-sRGB
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_COLOR_SPACE.JCS_BG_YCC">
            <summary>
            big gamut Y/Cb/Cr, bg-sYCC
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_COLOR_SPACE.JCS_NCHANNEL">
            <summary>
            N channels
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.J_COLOR_TRANSFORM">
            <summary>
            Supported color transforms.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_COLOR_TRANSFORM.JCT_NONE">
            <summary>
            No transform
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_COLOR_TRANSFORM.JCT_SUBTRACT_GREEN">
            <summary>
            Substract green
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.J_DCT_METHOD">
            <summary>
            Algorithm used for the DCT step.
            </summary>
            <remarks>The <c>FLOAT</c> method is very slightly more accurate than the <c>ISLOW</c> method,
            but may give different results on different machines due to varying roundoff behavior.
            The integer methods should give the same results on all machines. On machines with
            sufficiently fast hardware, the floating-point method may also be the fastest.
            The <c>IFAST</c> method is considerably less accurate than the other two; its use is not recommended
            if high quality is a concern.</remarks>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Dct_method"/>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Dct_method"/>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_DCT_METHOD.JDCT_ISLOW">
            <summary>
            Slow but accurate integer algorithm.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_DCT_METHOD.JDCT_IFAST">
            <summary>
            Faster, less accurate integer method.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_DCT_METHOD.JDCT_FLOAT">
            <summary>
            Floating-point method.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.J_DITHER_MODE">
            <summary>
            Dithering options for decompression.
            </summary>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Dither_mode"/>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_DITHER_MODE.JDITHER_NONE">
            <summary>
            No dithering: fast, very low quality
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_DITHER_MODE.JDITHER_ORDERED">
            <summary>
            Ordered dither: moderate speed and quality
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_DITHER_MODE.JDITHER_FS">
            <summary>
            Floyd-Steinberg dither: slow, high quality
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE">
            <summary>
            Message codes used in code to signal errors, warning and trace messages.
            </summary>
            <seealso cref="T:BitMiracle.LibJpeg.Classic.jpeg_error_mgr"/>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JMSG_NOMESSAGE">
            <summary>
            Must be first entry!
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_BUFFER_MODE">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_COMPONENT_ID">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_CROP_SPEC">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_DCT_COEF">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_DCTSIZE">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_DROP_SAMPLING">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_HUFF_TABLE">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_IN_COLORSPACE">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_J_COLORSPACE">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_LENGTH">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_MCU_SIZE">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_PRECISION">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_PROGRESSION">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_PROG_SCRIPT">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_SAMPLING">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_SCAN_SCRIPT">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_STATE">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_VIRTUAL_ACCESS">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BUFFER_SIZE">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_CANT_SUSPEND">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_CCIR601_NOTIMPL">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_COMPONENT_COUNT">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_CONVERSION_NOTIMPL">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_DAC_INDEX">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_DAC_VALUE">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_DHT_INDEX">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_DQT_INDEX">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_EMPTY_IMAGE">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_EOI_EXPECTED">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_FILE_WRITE">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_FRACT_SAMPLE_NOTIMPL">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_HUFF_CLEN_OVERFLOW">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_HUFF_MISSING_CODE">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_IMAGE_TOO_BIG">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_INPUT_EMPTY">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_INPUT_EOF">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_MISMATCHED_QUANT_TABLE">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_MISSING_DATA">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_MODE_CHANGE">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_NOTIMPL">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_NOT_COMPILED">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_NO_ARITH_TABLE">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_NO_HUFF_TABLE">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_NO_IMAGE">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_NO_QUANT_TABLE">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_NO_SOI">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_OUT_OF_MEMORY">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_QUANT_COMPONENTS">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_QUANT_FEW_COLORS">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_QUANT_MANY_COLORS">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_SOF_BEFORE">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_SOF_DUPLICATE">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_SOF_NO_SOS">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_SOF_UNSUPPORTED">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_SOI_DUPLICATE">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_SOS_NO_SOF">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_TOO_LITTLE_DATA">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_UNKNOWN_MARKER">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_WIDTH_OVERFLOW">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_16BIT_TABLES">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_ADOBE">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_APP0">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_APP14">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_DAC">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_DHT">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_DQT">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_DRI">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_EOI">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_HUFFBITS">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_JFIF">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_JFIF_BADTHUMBNAILSIZE">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_JFIF_EXTENSION">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_JFIF_THUMBNAIL">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_MISC_MARKER">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_PARMLESS_MARKER">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_QUANTVALS">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_QUANT_3_NCOLORS">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_QUANT_NCOLORS">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_QUANT_SELECTED">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_RECOVERY_ACTION">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_RST">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_SMOOTH_NOTIMPL">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_SOF">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_SOF_COMPONENT">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_SOI">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_SOS">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_SOS_COMPONENT">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_SOS_PARAMS">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_THUMB_JPEG">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_THUMB_PALETTE">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_THUMB_RGB">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_UNKNOWN_IDS">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JWRN_ADOBE_XFORM">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JWRN_ARITH_BAD_CODE">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JWRN_BOGUS_PROGRESSION">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JWRN_EXTRANEOUS_DATA">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JWRN_HIT_MARKER">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JWRN_HUFF_BAD_CODE">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JWRN_JFIF_MAJOR">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JWRN_JPEG_EOF">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JWRN_MUST_RESYNC">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JWRN_NOT_SEQUENTIAL">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JWRN_TOO_MUCH_DATA">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JMSG_UNKNOWNMSGCODE">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JMSG_LASTMSGCODE">
            <summary>
            
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.ReadResult">
            <summary>
            Describes a result of read operation.
            </summary>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_consume_input"/>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.ReadResult.JPEG_SUSPENDED">
            <summary>
            Suspended due to lack of input data. Can occur only if a suspending data source is used.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.ReadResult.JPEG_HEADER_OK">
            <summary>
            Found valid image datastream.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.ReadResult.JPEG_HEADER_TABLES_ONLY">
            <summary>
            Found valid table-specs-only datastream.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.ReadResult.JPEG_REACHED_SOS">
            <summary>
            Reached a SOS marker (the start of a new scan)
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.ReadResult.JPEG_REACHED_EOI">
            <summary>
            Reached the EOI marker (end of image)
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.ReadResult.JPEG_ROW_COMPLETED">
            <summary>
            Completed reading one MCU row of compressed data.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.ReadResult.JPEG_SCAN_COMPLETED">
            <summary>
            Completed reading last MCU row of current scan.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.CompressionParameters">
            <summary>
            Parameters of compression.
            </summary>
            <remarks>Being used in <see cref="M:BitMiracle.LibJpeg.JpegImage.WriteJpeg(System.IO.Stream,BitMiracle.LibJpeg.CompressionParameters)"/></remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.CompressionParameters.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:BitMiracle.LibJpeg.CompressionParameters"/> class.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.CompressionParameters.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to this instance.
            </summary>
            <param name="obj">The <see cref="T:System.Object"/> to compare with this instance.</param>
            <returns>
            	<c>true</c> if the specified <see cref="T:System.Object"/> is equal to this instance; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibJpeg.CompressionParameters.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms 
            and data structures like a hash table. 
            </returns>
        </member>
        <member name="P:BitMiracle.LibJpeg.CompressionParameters.Quality">
            <summary>
            Gets or sets the quality of JPEG image.
            </summary>
            <remarks>Default value: 75<br/>
            The quality value is expressed on the 0..100 scale.
            </remarks>
            <value>The quality of JPEG image.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.CompressionParameters.SmoothingFactor">
            <summary>
            Gets or sets the coefficient of image smoothing.
            </summary>
            <remarks>Default value: 0<br/>
            If non-zero, the input image is smoothed; the value should be 1 for
            minimal smoothing to 100 for maximum smoothing.
            </remarks>
            <value>The coefficient of image smoothing.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.CompressionParameters.SimpleProgressive">
            <summary>
            Gets or sets a value indicating whether to write a progressive-JPEG file.
            </summary>
            <value>
            <c>true</c> for writing a progressive-JPEG file; <c>false</c> 
            for non-progressive JPEG files.
            </value>
        </member>
        <member name="T:BitMiracle.LibJpeg.Colorspace">
            <summary>
            Known color spaces.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Colorspace.Unknown">
            <summary>
            Unspecified colorspace
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Colorspace.Grayscale">
            <summary>
            Grayscale
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Colorspace.RGB">
            <summary>
            RGB
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Colorspace.YCbCr">
            <summary>
            YCbCr (also known as YUV)
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Colorspace.CMYK">
            <summary>
            CMYK
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Colorspace.YCCK">
            <summary>
            YCbCrK
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.DCTMethod">
            <summary>
            DCT/IDCT algorithm options.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.DitherMode">
            <summary>
            Dithering options for decompression.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.IDecompressDestination">
            <summary>
            Common interface for processing of decompression.
            </summary>
        </member>
        <member name="P:BitMiracle.LibJpeg.IDecompressDestination.Output">
            <summary>
            Strean with decompressed data
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.IDecompressDestination.SetImageAttributes(BitMiracle.LibJpeg.LoadedImageAttributes)">
            <summary>
            Implementor of this interface should process image properties received from decompressor.
            </summary>
            <param name="parameters">Image properties</param>
        </member>
        <member name="M:BitMiracle.LibJpeg.IDecompressDestination.BeginWrite">
            <summary>
            Called before decompression
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.IDecompressDestination.ProcessPixelsRow(System.Byte[])">
            <summary>
            It called during decompression - pass row of pixels from JPEG
            </summary>
            <param name="row"></param>
        </member>
        <member name="M:BitMiracle.LibJpeg.IDecompressDestination.EndWrite">
            <summary>
            Called after decompression
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.LoadedImageAttributes">
            <summary>
            Holds parameters of image for decompression (IDecomressDesination)
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Jpeg">
            <summary>
            Internal wrapper for classic jpeg compressor and decompressor
            </summary>
        </member>
        <member name="P:BitMiracle.LibJpeg.Jpeg.CompressionParameters">
            <summary>
            Advanced users may set specific parameters of compression
            </summary>
        </member>
        <member name="P:BitMiracle.LibJpeg.Jpeg.DecompressionParameters">
            <summary>
            Advanced users may set specific parameters of decompression
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Jpeg.Compress(BitMiracle.LibJpeg.IRawImage,System.IO.Stream)">
            <summary>
            Compresses any image described as ICompressSource to JPEG
            </summary>
            <param name="source">Contains description of input image</param>
            <param name="output">Stream for output of compressed JPEG</param>
        </member>
        <member name="M:BitMiracle.LibJpeg.Jpeg.Decompress(System.IO.Stream,BitMiracle.LibJpeg.IDecompressDestination)">
            <summary>
            Decompresses JPEG image to any image described as ICompressDestination
            </summary>
            <param name="jpeg">Stream with JPEG data</param>
            <param name="destination">Stream for output of compressed JPEG</param>
        </member>
        <member name="M:BitMiracle.LibJpeg.Jpeg.beforeDecompress(System.IO.Stream)">
            <summary>
            Tunes decompressor
            </summary>
            <param name="jpeg">Stream with input compressed JPEG data</param>
        </member>
        <member name="T:BitMiracle.LibJpeg.Jpeg.MarkerParser">
            <summary>
            Delegate for application-supplied marker processing methods.
            Need not pass marker code since it is stored in cinfo.unread_marker.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.JpegImage">
            <summary>
            Main class for work with JPEG images.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.JpegImage.m_rows">
            <summary>
            Description of image pixels (samples)
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.JpegImage.m_compressedData">
            <summary>
            Bytes of jpeg image. Refreshed when m_compressionParameters changed.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.JpegImage.m_compressionParameters">
            <summary>
            Current compression parameters corresponding with compressed data.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.JpegImage.m_decompressedData">
            <summary>
            Bytes of decompressed image (bitmap)
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.JpegImage.#ctor(System.IO.Stream)">
            <summary>
            Creates <see cref="T:BitMiracle.LibJpeg.JpegImage"/> from stream with an arbitrary image data
            </summary>
            <param name="imageData">Stream containing bytes of image in 
            arbitrary format (BMP, Jpeg, GIF, PNG, TIFF, e.t.c)</param>
        </member>
        <member name="M:BitMiracle.LibJpeg.JpegImage.#ctor(BitMiracle.LibJpeg.SampleRow[],BitMiracle.LibJpeg.Colorspace)">
            <summary>
            Creates <see cref="T:BitMiracle.LibJpeg.JpegImage"/> from pixels
            </summary>
            <param name="sampleData">Description of pixels.</param>
            <param name="colorspace">Colorspace of image.</param>
            <seealso cref="T:BitMiracle.LibJpeg.SampleRow"/>
        </member>
        <member name="M:BitMiracle.LibJpeg.JpegImage.Dispose">
            <summary>
            Frees and releases all resources allocated by this <see cref="T:BitMiracle.LibJpeg.JpegImage"/>
            </summary>
        </member>
        <member name="P:BitMiracle.LibJpeg.JpegImage.Width">
            <summary>
            Gets the width of image in <see cref="T:BitMiracle.LibJpeg.Sample">samples</see>.
            </summary>
            <value>The width of image.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.JpegImage.Height">
            <summary>
            Gets the height of image in <see cref="T:BitMiracle.LibJpeg.Sample">samples</see>.
            </summary>
            <value>The height of image.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.JpegImage.ComponentsPerSample">
            <summary>
            Gets the number of color components per <see cref="T:BitMiracle.LibJpeg.Sample">sample</see>.
            </summary>
            <value>The number of color components per sample.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.JpegImage.BitsPerComponent">
            <summary>
            Gets the number of bits per color component of <see cref="T:BitMiracle.LibJpeg.Sample">sample</see>.
            </summary>
            <value>The number of bits per color component.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.JpegImage.Colorspace">
            <summary>
            Gets the colorspace of image.
            </summary>
            <value>The colorspace of image.</value>
        </member>
        <member name="M:BitMiracle.LibJpeg.JpegImage.GetRow(System.Int32)">
            <summary>
            Retrieves the required row of image.
            </summary>
            <param name="rowNumber">The number of row.</param>
            <returns>Image row of samples.</returns>
        </member>
        <member name="M:BitMiracle.LibJpeg.JpegImage.WriteJpeg(System.IO.Stream)">
            <summary>
            Writes compressed JPEG image to stream.
            </summary>
            <param name="output">Output stream.</param>
        </member>
        <member name="M:BitMiracle.LibJpeg.JpegImage.WriteJpeg(System.IO.Stream,BitMiracle.LibJpeg.CompressionParameters)">
            <summary>
            Compresses image to JPEG with given parameters and writes it to stream.
            </summary>
            <param name="output">Output stream.</param>
            <param name="parameters">The parameters of compression.</param>
        </member>
        <member name="M:BitMiracle.LibJpeg.JpegImage.WriteBitmap(System.IO.Stream)">
            <summary>
            Writes decompressed image data as bitmap to stream.
            </summary>
            <param name="output">Output stream.</param>
        </member>
        <member name="M:BitMiracle.LibJpeg.JpegImage.addSampleRow(BitMiracle.LibJpeg.SampleRow)">
            <summary>
            Needs for DecompressorToJpegImage class
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.JpegImage.isCompressed(System.IO.Stream)">
            <summary>
            Checks if imageData contains jpeg image
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Sample">
            <summary>
            Represents a "sample" (you can understand it as a "pixel") of image.
            </summary>
            <remarks>It's impossible to create an instance of this class directly, 
            but you can use existing samples through <see cref="T:BitMiracle.LibJpeg.SampleRow"/> collection. 
            Usual scenario is to get row of samples from the <see cref="M:BitMiracle.LibJpeg.JpegImage.GetRow(System.Int32)"/> method.
            </remarks>
        </member>
        <member name="P:BitMiracle.LibJpeg.Sample.BitsPerComponent">
            <summary>
            Gets the number of bits per color component.
            </summary>
            <value>The number of bits per color component.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Sample.ComponentCount">
            <summary>
            Gets the number of color components.
            </summary>
            <value>The number of color components.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Sample.Item(System.Int32)">
            <summary>
            Gets the color component at the specified index.
            </summary>
            <param name="componentNumber">The number of color component.</param>
            <returns>Value of color component.</returns>
        </member>
        <member name="M:BitMiracle.LibJpeg.Sample.GetComponent(System.Int32)">
            <summary>
            Gets the required color component.
            </summary>
            <param name="componentNumber">The number of color component.</param>
            <returns>Value of color component.</returns>
        </member>
        <member name="T:BitMiracle.LibJpeg.SampleRow">
            <summary>
            Represents a row of image - collection of samples.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.SampleRow.#ctor(System.Byte[],System.Int32,System.Byte,System.Byte)">
            <summary>
            Creates a row from raw samples data.
            </summary>
            <param name="row">Raw description of samples.<br/>
            You can pass collection with more than sampleCount samples - only sampleCount samples 
            will be parsed and all remaining bytes will be ignored.</param>
            <param name="sampleCount">The number of samples in row.</param>
            <param name="bitsPerComponent">The number of bits per component.</param>
            <param name="componentsPerSample">The number of components per sample.</param>
        </member>
        <member name="M:BitMiracle.LibJpeg.SampleRow.#ctor(System.Int16[],System.Byte,System.Byte)">
            <summary>
            Creates row from an array of components.
            </summary>
            <param name="sampleComponents">Array of color components.</param>
            <param name="bitsPerComponent">The number of bits per component.</param>
            <param name="componentsPerSample">The number of components per sample.</param>
            <remarks>The difference between this constructor and 
            <see cref="M:BitMiracle.LibJpeg.SampleRow.#ctor(System.Byte[],System.Int32,System.Byte,System.Byte)">another one</see> -
            this constructor accept an array of prepared color components whereas
            another constructor accept raw bytes and parse them.
            </remarks>
        </member>
        <member name="P:BitMiracle.LibJpeg.SampleRow.Length">
            <summary>
            Gets the number of samples in this row.
            </summary>
            <value>The number of samples.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.SampleRow.Item(System.Int32)">
            <summary>
            Gets the sample at the specified index.
            </summary>
            <param name="sampleNumber">The number of sample.</param>
            <returns>The required sample.</returns>
        </member>
        <member name="M:BitMiracle.LibJpeg.SampleRow.GetAt(System.Int32)">
            <summary>
            Gets the sample at the specified index.
            </summary>
            <param name="sampleNumber">The number of sample.</param>
            <returns>The required sample.</returns>
        </member>
        <member name="M:BitMiracle.LibJpeg.SampleRow.ToBytes">
            <summary>
            Serializes this row to raw bytes.
            </summary>
            <returns>The row representation as array of bytes</returns>
        </member>
    </members>
</doc>
